// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::object::Cast;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;
use super::PropertyTransition;
use super::Timeline;
use super::Transition;

glib_wrapper! {
    pub struct KeyframeTransition(Object<ffi::ClutterKeyframeTransition, ffi::ClutterKeyframeTransitionClass, KeyframeTransitionClass>) @extends PropertyTransition, Transition, Timeline;

    match fn {
        get_type => || ffi::clutter_keyframe_transition_get_type(),
    }
}

impl KeyframeTransition {
    pub fn new(property_name: &str) -> KeyframeTransition {
        assert_initialized_main_thread!();
        unsafe {
            Transition::from_glib_full(ffi::clutter_keyframe_transition_new(
                property_name.to_glib_none().0,
            ))
            .unsafe_cast()
        }
    }
}

pub const NONE_KEYFRAME_TRANSITION: Option<&KeyframeTransition> = None;

pub trait KeyframeTransitionExt: 'static {
    fn clear(&self);

    //fn get_key_frame(&self, index_: u32, value: /*Ignored*/glib::Value) -> (f64, AnimationMode);

    fn get_n_key_frames(&self) -> u32;

    //fn set(&self, gtype: glib::types::Type, n_key_frames: u32, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs);

    //fn set_key_frame(&self, index_: u32, key: f64, mode: AnimationMode, value: /*Ignored*/&glib::Value);

    fn set_key_frames(&self, key_frames: &[f64]);

    //fn set_modes(&self, modes: /*Unimplemented*/&CArray TypeId { ns_id: 1, id: 28 });

    //fn set_values(&self, values: /*Ignored*/&[&glib::Value]);
}

impl<O: IsA<KeyframeTransition>> KeyframeTransitionExt for O {
    fn clear(&self) {
        unsafe {
            ffi::clutter_keyframe_transition_clear(self.as_ref().to_glib_none().0);
        }
    }

    //fn get_key_frame(&self, index_: u32, value: /*Ignored*/glib::Value) -> (f64, AnimationMode) {
    //    unsafe { TODO: call clutter_sys:clutter_keyframe_transition_get_key_frame() }
    //}

    fn get_n_key_frames(&self) -> u32 {
        unsafe {
            ffi::clutter_keyframe_transition_get_n_key_frames(
                self.as_ref().to_glib_none().0,
            )
        }
    }

    //fn set(&self, gtype: glib::types::Type, n_key_frames: u32, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
    //    unsafe { TODO: call clutter_sys:clutter_keyframe_transition_set() }
    //}

    //fn set_key_frame(&self, index_: u32, key: f64, mode: AnimationMode, value: /*Ignored*/&glib::Value) {
    //    unsafe { TODO: call clutter_sys:clutter_keyframe_transition_set_key_frame() }
    //}

    fn set_key_frames(&self, key_frames: &[f64]) {
        let n_key_frames = key_frames.len() as u32;
        unsafe {
            ffi::clutter_keyframe_transition_set_key_frames(
                self.as_ref().to_glib_none().0,
                n_key_frames,
                key_frames.to_glib_none().0,
            );
        }
    }

    //fn set_modes(&self, modes: /*Unimplemented*/&CArray TypeId { ns_id: 1, id: 28 }) {
    //    unsafe { TODO: call clutter_sys:clutter_keyframe_transition_set_modes() }
    //}

    //fn set_values(&self, values: /*Ignored*/&[&glib::Value]) {
    //    unsafe { TODO: call clutter_sys:clutter_keyframe_transition_set_values() }
    //}
}

impl fmt::Display for KeyframeTransition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "KeyframeTransition")
    }
}
