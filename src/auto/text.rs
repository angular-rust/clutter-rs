// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::object::ObjectExt;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use libc;
use pango;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;
use super::Actor;
use super::Animatable;
use super::Color;
use super::Container;
use super::Rect;
use super::TextBuffer;

glib_wrapper! {
    pub struct Text(Object<ffi::ClutterText, ffi::ClutterTextClass, TextClass>) @extends Actor, @implements Animatable, Container;

    match fn {
        get_type => || ffi::clutter_text_get_type(),
    }
}

impl Text {
    pub fn new() -> Text {
        assert_initialized_main_thread!();
        unsafe { Actor::from_glib_none(ffi::clutter_text_new()).unsafe_cast() }
    }

    pub fn new_full(font_name: &str, text: &str, color: &Color) -> Text {
        assert_initialized_main_thread!();
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new_full(
                font_name.to_glib_none().0,
                text.to_glib_none().0,
                color.to_glib_none().0,
            ))
            .unsafe_cast()
        }
    }

    pub fn with_buffer<P: IsA<TextBuffer>>(buffer: &P) -> Text {
        skip_assert_initialized!();
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new_with_buffer(
                buffer.as_ref().to_glib_none().0,
            ))
            .unsafe_cast()
        }
    }

    pub fn with_text(font_name: Option<&str>, text: &str) -> Text {
        assert_initialized_main_thread!();
        unsafe {
            Actor::from_glib_none(ffi::clutter_text_new_with_text(
                font_name.to_glib_none().0,
                text.to_glib_none().0,
            ))
            .unsafe_cast()
        }
    }
}

impl Default for Text {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_TEXT: Option<&Text> = None;

pub trait TextExt: 'static {
    fn activate(&self) -> bool;

    fn coords_to_position(&self, x: f32, y: f32) -> i32;

    fn delete_chars(&self, n_chars: u32);

    fn delete_selection(&self) -> bool;

    fn delete_text(&self, start_pos: isize, end_pos: isize);

    fn get_activatable(&self) -> bool;

    fn get_attributes(&self) -> Option<pango::AttrList>;

    fn get_buffer(&self) -> Option<TextBuffer>;

    fn get_chars(&self, start_pos: isize, end_pos: isize) -> Option<GString>;

    fn get_color(&self) -> Color;

    fn get_cursor_color(&self) -> Color;

    fn get_cursor_position(&self) -> i32;

    fn get_cursor_rect(&self) -> Rect;

    fn get_cursor_size(&self) -> u32;

    fn get_cursor_visible(&self) -> bool;

    fn get_editable(&self) -> bool;

    fn get_ellipsize(&self) -> pango::EllipsizeMode;

    fn get_font_description(&self) -> Option<pango::FontDescription>;

    fn get_font_name(&self) -> Option<GString>;

    fn get_justify(&self) -> bool;

    fn get_layout(&self) -> Option<pango::Layout>;

    fn get_layout_offsets(&self) -> (i32, i32);

    fn get_line_alignment(&self) -> pango::Alignment;

    fn get_line_wrap(&self) -> bool;

    fn get_line_wrap_mode(&self) -> pango::WrapMode;

    fn get_max_length(&self) -> i32;

    fn get_password_char(&self) -> char;

    fn get_selectable(&self) -> bool;

    fn get_selected_text_color(&self) -> Color;

    fn get_selection(&self) -> Option<GString>;

    fn get_selection_bound(&self) -> i32;

    fn get_selection_color(&self) -> Color;

    fn get_single_line_mode(&self) -> bool;

    fn get_text(&self) -> Option<GString>;

    fn get_use_markup(&self) -> bool;

    fn insert_text(&self, text: &str, position: isize);

    fn insert_unichar(&self, wc: char);

    fn position_to_coords(&self, position: i32) -> Option<(f32, f32, f32)>;

    fn set_activatable(&self, activatable: bool);

    fn set_attributes(&self, attrs: Option<&pango::AttrList>);

    fn set_buffer<P: IsA<TextBuffer>>(&self, buffer: &P);

    fn set_color(&self, color: &Color);

    fn set_cursor_color(&self, color: Option<&Color>);

    fn set_cursor_position(&self, position: i32);

    fn set_cursor_size(&self, size: i32);

    fn set_cursor_visible(&self, cursor_visible: bool);

    fn set_editable(&self, editable: bool);

    fn set_ellipsize(&self, mode: pango::EllipsizeMode);

    fn set_font_description(&self, font_desc: &mut pango::FontDescription);

    fn set_font_name(&self, font_name: Option<&str>);

    fn set_justify(&self, justify: bool);

    fn set_line_alignment(&self, alignment: pango::Alignment);

    fn set_line_wrap(&self, line_wrap: bool);

    fn set_line_wrap_mode(&self, wrap_mode: pango::WrapMode);

    fn set_markup(&self, markup: Option<&str>);

    fn set_max_length(&self, max: i32);

    fn set_password_char(&self, wc: char);

    fn set_preedit_string(
        &self,
        preedit_str: Option<&str>,
        preedit_attrs: Option<&pango::AttrList>,
        cursor_pos: u32,
    );

    fn set_selectable(&self, selectable: bool);

    fn set_selected_text_color(&self, color: Option<&Color>);

    fn set_selection(&self, start_pos: isize, end_pos: isize);

    fn set_selection_bound(&self, selection_bound: i32);

    fn set_selection_color(&self, color: Option<&Color>);

    fn set_single_line_mode(&self, single_line: bool);

    fn set_text(&self, text: Option<&str>);

    fn set_use_markup(&self, setting: bool);

    fn get_property_cursor_color_set(&self) -> bool;

    fn get_property_selected_text_color_set(&self) -> bool;

    fn get_property_selection_color_set(&self) -> bool;

    fn connect_activate<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_cursor_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_delete_text<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    fn emit_delete_text(&self, start_pos: i32, end_pos: i32);

    //fn connect_insert_text<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    fn connect_text_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_activatable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_attributes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_buffer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_cursor_color_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_cursor_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_cursor_position_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_cursor_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_cursor_visible_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_editable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_ellipsize_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_font_description_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_font_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_justify_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_line_alignment_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_line_wrap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_line_wrap_mode_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_max_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_password_char_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_selectable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_selected_text_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_selected_text_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_selection_bound_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_selection_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_selection_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_single_line_mode_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_text_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_use_markup_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Text>> TextExt for O {
    fn activate(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_activate(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn coords_to_position(&self, x: f32, y: f32) -> i32 {
        unsafe {
            ffi::clutter_text_coords_to_position(self.as_ref().to_glib_none().0, x, y)
        }
    }

    fn delete_chars(&self, n_chars: u32) {
        unsafe {
            ffi::clutter_text_delete_chars(self.as_ref().to_glib_none().0, n_chars);
        }
    }

    fn delete_selection(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_delete_selection(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn delete_text(&self, start_pos: isize, end_pos: isize) {
        unsafe {
            ffi::clutter_text_delete_text(
                self.as_ref().to_glib_none().0,
                start_pos,
                end_pos,
            );
        }
    }

    fn get_activatable(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_activatable(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_attributes(&self) -> Option<pango::AttrList> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_attributes(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_buffer(&self) -> Option<TextBuffer> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_buffer(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_chars(&self, start_pos: isize, end_pos: isize) -> Option<GString> {
        unsafe {
            from_glib_full(ffi::clutter_text_get_chars(
                self.as_ref().to_glib_none().0,
                start_pos,
                end_pos,
            ))
        }
    }

    fn get_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none_mut().0,
            );
            color
        }
    }

    fn get_cursor_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_cursor_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none_mut().0,
            );
            color
        }
    }

    fn get_cursor_position(&self) -> i32 {
        unsafe { ffi::clutter_text_get_cursor_position(self.as_ref().to_glib_none().0) }
    }

    fn get_cursor_rect(&self) -> Rect {
        unsafe {
            let mut rect = Rect::uninitialized();
            ffi::clutter_text_get_cursor_rect(
                self.as_ref().to_glib_none().0,
                rect.to_glib_none_mut().0,
            );
            rect
        }
    }

    fn get_cursor_size(&self) -> u32 {
        unsafe { ffi::clutter_text_get_cursor_size(self.as_ref().to_glib_none().0) }
    }

    fn get_cursor_visible(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_cursor_visible(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_editable(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_editable(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_ellipsize(&self) -> pango::EllipsizeMode {
        unsafe {
            from_glib(ffi::clutter_text_get_ellipsize(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_font_description(&self) -> Option<pango::FontDescription> {
        unsafe {
            from_glib_full(ffi::clutter_text_get_font_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_font_name(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_font_name(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_justify(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_justify(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_layout(&self) -> Option<pango::Layout> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_layout(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_layout_offsets(&self) -> (i32, i32) {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            ffi::clutter_text_get_layout_offsets(
                self.as_ref().to_glib_none().0,
                x.as_mut_ptr(),
                y.as_mut_ptr(),
            );
            let x = x.assume_init();
            let y = y.assume_init();
            (x, y)
        }
    }

    fn get_line_alignment(&self) -> pango::Alignment {
        unsafe {
            from_glib(ffi::clutter_text_get_line_alignment(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_line_wrap(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_line_wrap(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_line_wrap_mode(&self) -> pango::WrapMode {
        unsafe {
            from_glib(ffi::clutter_text_get_line_wrap_mode(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_max_length(&self) -> i32 {
        unsafe { ffi::clutter_text_get_max_length(self.as_ref().to_glib_none().0) }
    }

    fn get_password_char(&self) -> char {
        unsafe {
            from_glib(ffi::clutter_text_get_password_char(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_selectable(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_selectable(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_selected_text_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_selected_text_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none_mut().0,
            );
            color
        }
    }

    fn get_selection(&self) -> Option<GString> {
        unsafe {
            from_glib_full(ffi::clutter_text_get_selection(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_selection_bound(&self) -> i32 {
        unsafe { ffi::clutter_text_get_selection_bound(self.as_ref().to_glib_none().0) }
    }

    fn get_selection_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_text_get_selection_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none_mut().0,
            );
            color
        }
    }

    fn get_single_line_mode(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_single_line_mode(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_text(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ffi::clutter_text_get_text(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_use_markup(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_text_get_use_markup(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn insert_text(&self, text: &str, position: isize) {
        unsafe {
            ffi::clutter_text_insert_text(
                self.as_ref().to_glib_none().0,
                text.to_glib_none().0,
                position,
            );
        }
    }

    fn insert_unichar(&self, wc: char) {
        unsafe {
            ffi::clutter_text_insert_unichar(self.as_ref().to_glib_none().0, wc.to_glib());
        }
    }

    fn position_to_coords(&self, position: i32) -> Option<(f32, f32, f32)> {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            let mut line_height = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::clutter_text_position_to_coords(
                self.as_ref().to_glib_none().0,
                position,
                x.as_mut_ptr(),
                y.as_mut_ptr(),
                line_height.as_mut_ptr(),
            ));
            let x = x.assume_init();
            let y = y.assume_init();
            let line_height = line_height.assume_init();
            if ret {
                Some((x, y, line_height))
            } else {
                None
            }
        }
    }

    fn set_activatable(&self, activatable: bool) {
        unsafe {
            ffi::clutter_text_set_activatable(
                self.as_ref().to_glib_none().0,
                activatable.to_glib(),
            );
        }
    }

    fn set_attributes(&self, attrs: Option<&pango::AttrList>) {
        unsafe {
            ffi::clutter_text_set_attributes(
                self.as_ref().to_glib_none().0,
                attrs.to_glib_none().0,
            );
        }
    }

    fn set_buffer<P: IsA<TextBuffer>>(&self, buffer: &P) {
        unsafe {
            ffi::clutter_text_set_buffer(
                self.as_ref().to_glib_none().0,
                buffer.as_ref().to_glib_none().0,
            );
        }
    }

    fn set_color(&self, color: &Color) {
        unsafe {
            ffi::clutter_text_set_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none().0,
            );
        }
    }

    fn set_cursor_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_text_set_cursor_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none().0,
            );
        }
    }

    fn set_cursor_position(&self, position: i32) {
        unsafe {
            ffi::clutter_text_set_cursor_position(self.as_ref().to_glib_none().0, position);
        }
    }

    fn set_cursor_size(&self, size: i32) {
        unsafe {
            ffi::clutter_text_set_cursor_size(self.as_ref().to_glib_none().0, size);
        }
    }

    fn set_cursor_visible(&self, cursor_visible: bool) {
        unsafe {
            ffi::clutter_text_set_cursor_visible(
                self.as_ref().to_glib_none().0,
                cursor_visible.to_glib(),
            );
        }
    }

    fn set_editable(&self, editable: bool) {
        unsafe {
            ffi::clutter_text_set_editable(
                self.as_ref().to_glib_none().0,
                editable.to_glib(),
            );
        }
    }

    fn set_ellipsize(&self, mode: pango::EllipsizeMode) {
        unsafe {
            ffi::clutter_text_set_ellipsize(self.as_ref().to_glib_none().0, mode.to_glib());
        }
    }

    fn set_font_description(&self, font_desc: &mut pango::FontDescription) {
        unsafe {
            ffi::clutter_text_set_font_description(
                self.as_ref().to_glib_none().0,
                font_desc.to_glib_none_mut().0,
            );
        }
    }

    fn set_font_name(&self, font_name: Option<&str>) {
        unsafe {
            ffi::clutter_text_set_font_name(
                self.as_ref().to_glib_none().0,
                font_name.to_glib_none().0,
            );
        }
    }

    fn set_justify(&self, justify: bool) {
        unsafe {
            ffi::clutter_text_set_justify(
                self.as_ref().to_glib_none().0,
                justify.to_glib(),
            );
        }
    }

    fn set_line_alignment(&self, alignment: pango::Alignment) {
        unsafe {
            ffi::clutter_text_set_line_alignment(
                self.as_ref().to_glib_none().0,
                alignment.to_glib(),
            );
        }
    }

    fn set_line_wrap(&self, line_wrap: bool) {
        unsafe {
            ffi::clutter_text_set_line_wrap(
                self.as_ref().to_glib_none().0,
                line_wrap.to_glib(),
            );
        }
    }

    fn set_line_wrap_mode(&self, wrap_mode: pango::WrapMode) {
        unsafe {
            ffi::clutter_text_set_line_wrap_mode(
                self.as_ref().to_glib_none().0,
                wrap_mode.to_glib(),
            );
        }
    }

    fn set_markup(&self, markup: Option<&str>) {
        unsafe {
            ffi::clutter_text_set_markup(
                self.as_ref().to_glib_none().0,
                markup.to_glib_none().0,
            );
        }
    }

    fn set_max_length(&self, max: i32) {
        unsafe {
            ffi::clutter_text_set_max_length(self.as_ref().to_glib_none().0, max);
        }
    }

    fn set_password_char(&self, wc: char) {
        unsafe {
            ffi::clutter_text_set_password_char(
                self.as_ref().to_glib_none().0,
                wc.to_glib(),
            );
        }
    }

    fn set_preedit_string(
        &self,
        preedit_str: Option<&str>,
        preedit_attrs: Option<&pango::AttrList>,
        cursor_pos: u32,
    ) {
        unsafe {
            ffi::clutter_text_set_preedit_string(
                self.as_ref().to_glib_none().0,
                preedit_str.to_glib_none().0,
                preedit_attrs.to_glib_none().0,
                cursor_pos,
            );
        }
    }

    fn set_selectable(&self, selectable: bool) {
        unsafe {
            ffi::clutter_text_set_selectable(
                self.as_ref().to_glib_none().0,
                selectable.to_glib(),
            );
        }
    }

    fn set_selected_text_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_text_set_selected_text_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none().0,
            );
        }
    }

    fn set_selection(&self, start_pos: isize, end_pos: isize) {
        unsafe {
            ffi::clutter_text_set_selection(
                self.as_ref().to_glib_none().0,
                start_pos,
                end_pos,
            );
        }
    }

    fn set_selection_bound(&self, selection_bound: i32) {
        unsafe {
            ffi::clutter_text_set_selection_bound(
                self.as_ref().to_glib_none().0,
                selection_bound,
            );
        }
    }

    fn set_selection_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_text_set_selection_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none().0,
            );
        }
    }

    fn set_single_line_mode(&self, single_line: bool) {
        unsafe {
            ffi::clutter_text_set_single_line_mode(
                self.as_ref().to_glib_none().0,
                single_line.to_glib(),
            );
        }
    }

    fn set_text(&self, text: Option<&str>) {
        unsafe {
            ffi::clutter_text_set_text(
                self.as_ref().to_glib_none().0,
                text.to_glib_none().0,
            );
        }
    }

    fn set_use_markup(&self, setting: bool) {
        unsafe {
            ffi::clutter_text_set_use_markup(
                self.as_ref().to_glib_none().0,
                setting.to_glib(),
            );
        }
    }

    fn get_property_cursor_color_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"cursor-color-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `cursor-color-set` getter")
                .unwrap()
        }
    }

    fn get_property_selected_text_color_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"selected-text-color-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `selected-text-color-set` getter")
                .unwrap()
        }
    }

    fn get_property_selection_color_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"selection-color-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `selection-color-set` getter")
                .unwrap()
        }
    }

    fn connect_activate<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn activate_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"activate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    activate_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_cursor_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn cursor_changed_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"cursor-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    cursor_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_delete_text<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn delete_text_trampoline<P, F: Fn(&P, i32, i32) + 'static>(
            this: *mut ffi::ClutterText,
            start_pos: libc::c_int,
            end_pos: libc::c_int,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Text::from_glib_borrow(this).unsafe_cast_ref(),
                start_pos,
                end_pos,
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"delete-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    delete_text_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn emit_delete_text(&self, start_pos: i32, end_pos: i32) {
        let _ = unsafe {
            glib::Object::from_glib_borrow(self.as_ptr() as *mut gobject_sys::GObject)
                .emit("delete-text", &[&start_pos, &end_pos])
                .unwrap()
        };
    }

    //fn connect_insert_text<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented position: *.Pointer
    //}

    fn connect_text_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn text_changed_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"text-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    text_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_activatable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_activatable_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::activatable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_activatable_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_attributes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_attributes_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::attributes\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_attributes_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_buffer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_buffer_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::buffer\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_buffer_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_color_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_color_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_color_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_cursor_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_color_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::cursor-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_cursor_color_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_cursor_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_color_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::cursor-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_cursor_color_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_cursor_position_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_position_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::cursor-position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_cursor_position_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_cursor_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_size_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::cursor-size\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_cursor_size_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_cursor_visible_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_cursor_visible_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::cursor-visible\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_cursor_visible_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_editable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_editable_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::editable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_editable_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_ellipsize_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ellipsize_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::ellipsize\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_ellipsize_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_font_description_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_font_description_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::font-description\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_font_description_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_font_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_font_name_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::font-name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_font_name_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_justify_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_justify_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::justify\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_justify_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_line_alignment_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_line_alignment_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::line-alignment\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_line_alignment_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_line_wrap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_line_wrap_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::line-wrap\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_line_wrap_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_line_wrap_mode_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_line_wrap_mode_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::line-wrap-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_line_wrap_mode_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_max_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_max_length_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::max-length\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_max_length_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_password_char_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_char_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::password-char\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_password_char_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_selectable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_selectable_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::selectable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_selectable_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_selected_text_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_selected_text_color_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::selected-text-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_selected_text_color_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_selected_text_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_selected_text_color_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::selected-text-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_selected_text_color_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_selection_bound_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_selection_bound_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::selection-bound\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_selection_bound_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_selection_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_selection_color_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::selection-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_selection_color_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_selection_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_selection_color_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::selection-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_selection_color_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_single_line_mode_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_single_line_mode_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::single-line-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_single_line_mode_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_text_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_text_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_text_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_use_markup_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_use_markup_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterText,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Text>,
        {
            let f: &F = &*(f as *const F);
            f(&Text::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::use-markup\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_use_markup_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Text {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Text")
    }
}
