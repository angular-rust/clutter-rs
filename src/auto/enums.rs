// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ActorAlign {
    Fill,
    Start,
    Center,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ActorAlign {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ActorAlign::{}",
            match *self {
                ActorAlign::Fill => "Fill",
                ActorAlign::Start => "Start",
                ActorAlign::Center => "Center",
                ActorAlign::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ActorAlign {
    type GlibType = ffi::ClutterActorAlign;

    fn to_glib(&self) -> ffi::ClutterActorAlign {
        match *self {
            ActorAlign::Fill => ffi::CLUTTER_ACTOR_ALIGN_FILL,
            ActorAlign::Start => ffi::CLUTTER_ACTOR_ALIGN_START,
            ActorAlign::Center => ffi::CLUTTER_ACTOR_ALIGN_CENTER,
            ActorAlign::End => ffi::CLUTTER_ACTOR_ALIGN_END,
            ActorAlign::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterActorAlign> for ActorAlign {
    fn from_glib(value: ffi::ClutterActorAlign) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ActorAlign::Fill,
            1 => ActorAlign::Start,
            2 => ActorAlign::Center,
            3 => ActorAlign::End,
            value => ActorAlign::__Unknown(value),
        }
    }
}

impl StaticType for ActorAlign {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_actor_align_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ActorAlign {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ActorAlign {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ActorAlign {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AlignAxis {
    XAxis,
    YAxis,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AlignAxis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AlignAxis::{}",
            match *self {
                AlignAxis::XAxis => "XAxis",
                AlignAxis::YAxis => "YAxis",
                AlignAxis::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AlignAxis {
    type GlibType = ffi::ClutterAlignAxis;

    fn to_glib(&self) -> ffi::ClutterAlignAxis {
        match *self {
            AlignAxis::XAxis => ffi::CLUTTER_ALIGN_X_AXIS,
            AlignAxis::YAxis => ffi::CLUTTER_ALIGN_Y_AXIS,
            AlignAxis::Both => ffi::CLUTTER_ALIGN_BOTH,
            AlignAxis::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterAlignAxis> for AlignAxis {
    fn from_glib(value: ffi::ClutterAlignAxis) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AlignAxis::XAxis,
            1 => AlignAxis::YAxis,
            2 => AlignAxis::Both,
            value => AlignAxis::__Unknown(value),
        }
    }
}

impl StaticType for AlignAxis {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_align_axis_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AlignAxis {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AlignAxis {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AlignAxis {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AnimationMode {
    CustomMode,
    Linear,
    EaseInQuad,
    EaseOutQuad,
    EaseInOutQuad,
    EaseInCubic,
    EaseOutCubic,
    EaseInOutCubic,
    EaseInQuart,
    EaseOutQuart,
    EaseInOutQuart,
    EaseInQuint,
    EaseOutQuint,
    EaseInOutQuint,
    EaseInSine,
    EaseOutSine,
    EaseInOutSine,
    EaseInExpo,
    EaseOutExpo,
    EaseInOutExpo,
    EaseInCirc,
    EaseOutCirc,
    EaseInOutCirc,
    EaseInElastic,
    EaseOutElastic,
    EaseInOutElastic,
    EaseInBack,
    EaseOutBack,
    EaseInOutBack,
    EaseInBounce,
    EaseOutBounce,
    EaseInOutBounce,
    Steps,
    StepStart,
    StepEnd,
    CubicBezier,
    Ease,
    EaseIn,
    EaseOut,
    EaseInOut,
    AnimationLast,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AnimationMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AnimationMode::{}",
            match *self {
                AnimationMode::CustomMode => "CustomMode",
                AnimationMode::Linear => "Linear",
                AnimationMode::EaseInQuad => "EaseInQuad",
                AnimationMode::EaseOutQuad => "EaseOutQuad",
                AnimationMode::EaseInOutQuad => "EaseInOutQuad",
                AnimationMode::EaseInCubic => "EaseInCubic",
                AnimationMode::EaseOutCubic => "EaseOutCubic",
                AnimationMode::EaseInOutCubic => "EaseInOutCubic",
                AnimationMode::EaseInQuart => "EaseInQuart",
                AnimationMode::EaseOutQuart => "EaseOutQuart",
                AnimationMode::EaseInOutQuart => "EaseInOutQuart",
                AnimationMode::EaseInQuint => "EaseInQuint",
                AnimationMode::EaseOutQuint => "EaseOutQuint",
                AnimationMode::EaseInOutQuint => "EaseInOutQuint",
                AnimationMode::EaseInSine => "EaseInSine",
                AnimationMode::EaseOutSine => "EaseOutSine",
                AnimationMode::EaseInOutSine => "EaseInOutSine",
                AnimationMode::EaseInExpo => "EaseInExpo",
                AnimationMode::EaseOutExpo => "EaseOutExpo",
                AnimationMode::EaseInOutExpo => "EaseInOutExpo",
                AnimationMode::EaseInCirc => "EaseInCirc",
                AnimationMode::EaseOutCirc => "EaseOutCirc",
                AnimationMode::EaseInOutCirc => "EaseInOutCirc",
                AnimationMode::EaseInElastic => "EaseInElastic",
                AnimationMode::EaseOutElastic => "EaseOutElastic",
                AnimationMode::EaseInOutElastic => "EaseInOutElastic",
                AnimationMode::EaseInBack => "EaseInBack",
                AnimationMode::EaseOutBack => "EaseOutBack",
                AnimationMode::EaseInOutBack => "EaseInOutBack",
                AnimationMode::EaseInBounce => "EaseInBounce",
                AnimationMode::EaseOutBounce => "EaseOutBounce",
                AnimationMode::EaseInOutBounce => "EaseInOutBounce",
                AnimationMode::Steps => "Steps",
                AnimationMode::StepStart => "StepStart",
                AnimationMode::StepEnd => "StepEnd",
                AnimationMode::CubicBezier => "CubicBezier",
                AnimationMode::Ease => "Ease",
                AnimationMode::EaseIn => "EaseIn",
                AnimationMode::EaseOut => "EaseOut",
                AnimationMode::EaseInOut => "EaseInOut",
                AnimationMode::AnimationLast => "AnimationLast",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AnimationMode {
    type GlibType = ffi::ClutterAnimationMode;

    fn to_glib(&self) -> ffi::ClutterAnimationMode {
        match *self {
            AnimationMode::CustomMode => ffi::CLUTTER_CUSTOM_MODE,
            AnimationMode::Linear => ffi::CLUTTER_LINEAR,
            AnimationMode::EaseInQuad => ffi::CLUTTER_EASE_IN_QUAD,
            AnimationMode::EaseOutQuad => ffi::CLUTTER_EASE_OUT_QUAD,
            AnimationMode::EaseInOutQuad => ffi::CLUTTER_EASE_IN_OUT_QUAD,
            AnimationMode::EaseInCubic => ffi::CLUTTER_EASE_IN_CUBIC,
            AnimationMode::EaseOutCubic => ffi::CLUTTER_EASE_OUT_CUBIC,
            AnimationMode::EaseInOutCubic => ffi::CLUTTER_EASE_IN_OUT_CUBIC,
            AnimationMode::EaseInQuart => ffi::CLUTTER_EASE_IN_QUART,
            AnimationMode::EaseOutQuart => ffi::CLUTTER_EASE_OUT_QUART,
            AnimationMode::EaseInOutQuart => ffi::CLUTTER_EASE_IN_OUT_QUART,
            AnimationMode::EaseInQuint => ffi::CLUTTER_EASE_IN_QUINT,
            AnimationMode::EaseOutQuint => ffi::CLUTTER_EASE_OUT_QUINT,
            AnimationMode::EaseInOutQuint => ffi::CLUTTER_EASE_IN_OUT_QUINT,
            AnimationMode::EaseInSine => ffi::CLUTTER_EASE_IN_SINE,
            AnimationMode::EaseOutSine => ffi::CLUTTER_EASE_OUT_SINE,
            AnimationMode::EaseInOutSine => ffi::CLUTTER_EASE_IN_OUT_SINE,
            AnimationMode::EaseInExpo => ffi::CLUTTER_EASE_IN_EXPO,
            AnimationMode::EaseOutExpo => ffi::CLUTTER_EASE_OUT_EXPO,
            AnimationMode::EaseInOutExpo => ffi::CLUTTER_EASE_IN_OUT_EXPO,
            AnimationMode::EaseInCirc => ffi::CLUTTER_EASE_IN_CIRC,
            AnimationMode::EaseOutCirc => ffi::CLUTTER_EASE_OUT_CIRC,
            AnimationMode::EaseInOutCirc => ffi::CLUTTER_EASE_IN_OUT_CIRC,
            AnimationMode::EaseInElastic => ffi::CLUTTER_EASE_IN_ELASTIC,
            AnimationMode::EaseOutElastic => ffi::CLUTTER_EASE_OUT_ELASTIC,
            AnimationMode::EaseInOutElastic => ffi::CLUTTER_EASE_IN_OUT_ELASTIC,
            AnimationMode::EaseInBack => ffi::CLUTTER_EASE_IN_BACK,
            AnimationMode::EaseOutBack => ffi::CLUTTER_EASE_OUT_BACK,
            AnimationMode::EaseInOutBack => ffi::CLUTTER_EASE_IN_OUT_BACK,
            AnimationMode::EaseInBounce => ffi::CLUTTER_EASE_IN_BOUNCE,
            AnimationMode::EaseOutBounce => ffi::CLUTTER_EASE_OUT_BOUNCE,
            AnimationMode::EaseInOutBounce => ffi::CLUTTER_EASE_IN_OUT_BOUNCE,
            AnimationMode::Steps => ffi::CLUTTER_STEPS,
            AnimationMode::StepStart => ffi::CLUTTER_STEP_START,
            AnimationMode::StepEnd => ffi::CLUTTER_STEP_END,
            AnimationMode::CubicBezier => ffi::CLUTTER_CUBIC_BEZIER,
            AnimationMode::Ease => ffi::CLUTTER_EASE,
            AnimationMode::EaseIn => ffi::CLUTTER_EASE_IN,
            AnimationMode::EaseOut => ffi::CLUTTER_EASE_OUT,
            AnimationMode::EaseInOut => ffi::CLUTTER_EASE_IN_OUT,
            AnimationMode::AnimationLast => ffi::CLUTTER_ANIMATION_LAST,
            AnimationMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterAnimationMode> for AnimationMode {
    fn from_glib(value: ffi::ClutterAnimationMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AnimationMode::CustomMode,
            1 => AnimationMode::Linear,
            2 => AnimationMode::EaseInQuad,
            3 => AnimationMode::EaseOutQuad,
            4 => AnimationMode::EaseInOutQuad,
            5 => AnimationMode::EaseInCubic,
            6 => AnimationMode::EaseOutCubic,
            7 => AnimationMode::EaseInOutCubic,
            8 => AnimationMode::EaseInQuart,
            9 => AnimationMode::EaseOutQuart,
            10 => AnimationMode::EaseInOutQuart,
            11 => AnimationMode::EaseInQuint,
            12 => AnimationMode::EaseOutQuint,
            13 => AnimationMode::EaseInOutQuint,
            14 => AnimationMode::EaseInSine,
            15 => AnimationMode::EaseOutSine,
            16 => AnimationMode::EaseInOutSine,
            17 => AnimationMode::EaseInExpo,
            18 => AnimationMode::EaseOutExpo,
            19 => AnimationMode::EaseInOutExpo,
            20 => AnimationMode::EaseInCirc,
            21 => AnimationMode::EaseOutCirc,
            22 => AnimationMode::EaseInOutCirc,
            23 => AnimationMode::EaseInElastic,
            24 => AnimationMode::EaseOutElastic,
            25 => AnimationMode::EaseInOutElastic,
            26 => AnimationMode::EaseInBack,
            27 => AnimationMode::EaseOutBack,
            28 => AnimationMode::EaseInOutBack,
            29 => AnimationMode::EaseInBounce,
            30 => AnimationMode::EaseOutBounce,
            31 => AnimationMode::EaseInOutBounce,
            32 => AnimationMode::Steps,
            33 => AnimationMode::StepStart,
            34 => AnimationMode::StepEnd,
            35 => AnimationMode::CubicBezier,
            36 => AnimationMode::Ease,
            37 => AnimationMode::EaseIn,
            38 => AnimationMode::EaseOut,
            39 => AnimationMode::EaseInOut,
            40 => AnimationMode::AnimationLast,
            value => AnimationMode::__Unknown(value),
        }
    }
}

impl StaticType for AnimationMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_animation_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AnimationMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AnimationMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AnimationMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BinAlignment {
    Fixed,
    Fill,
    Start,
    End,
    Center,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BinAlignment {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BinAlignment::{}",
            match *self {
                BinAlignment::Fixed => "Fixed",
                BinAlignment::Fill => "Fill",
                BinAlignment::Start => "Start",
                BinAlignment::End => "End",
                BinAlignment::Center => "Center",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BinAlignment {
    type GlibType = ffi::ClutterBinAlignment;

    fn to_glib(&self) -> ffi::ClutterBinAlignment {
        match *self {
            BinAlignment::Fixed => ffi::CLUTTER_BIN_ALIGNMENT_FIXED,
            BinAlignment::Fill => ffi::CLUTTER_BIN_ALIGNMENT_FILL,
            BinAlignment::Start => ffi::CLUTTER_BIN_ALIGNMENT_START,
            BinAlignment::End => ffi::CLUTTER_BIN_ALIGNMENT_END,
            BinAlignment::Center => ffi::CLUTTER_BIN_ALIGNMENT_CENTER,
            BinAlignment::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterBinAlignment> for BinAlignment {
    fn from_glib(value: ffi::ClutterBinAlignment) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BinAlignment::Fixed,
            1 => BinAlignment::Fill,
            2 => BinAlignment::Start,
            3 => BinAlignment::End,
            4 => BinAlignment::Center,
            value => BinAlignment::__Unknown(value),
        }
    }
}

impl StaticType for BinAlignment {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_bin_alignment_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BinAlignment {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BinAlignment {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BinAlignment {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BindCoordinate {
    X,
    Y,
    Width,
    Height,
    Position,
    Size,
    All,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BindCoordinate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BindCoordinate::{}",
            match *self {
                BindCoordinate::X => "X",
                BindCoordinate::Y => "Y",
                BindCoordinate::Width => "Width",
                BindCoordinate::Height => "Height",
                BindCoordinate::Position => "Position",
                BindCoordinate::Size => "Size",
                BindCoordinate::All => "All",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BindCoordinate {
    type GlibType = ffi::ClutterBindCoordinate;

    fn to_glib(&self) -> ffi::ClutterBindCoordinate {
        match *self {
            BindCoordinate::X => ffi::CLUTTER_BIND_X,
            BindCoordinate::Y => ffi::CLUTTER_BIND_Y,
            BindCoordinate::Width => ffi::CLUTTER_BIND_WIDTH,
            BindCoordinate::Height => ffi::CLUTTER_BIND_HEIGHT,
            BindCoordinate::Position => ffi::CLUTTER_BIND_POSITION,
            BindCoordinate::Size => ffi::CLUTTER_BIND_SIZE,
            BindCoordinate::All => ffi::CLUTTER_BIND_ALL,
            BindCoordinate::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterBindCoordinate> for BindCoordinate {
    fn from_glib(value: ffi::ClutterBindCoordinate) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BindCoordinate::X,
            1 => BindCoordinate::Y,
            2 => BindCoordinate::Width,
            3 => BindCoordinate::Height,
            4 => BindCoordinate::Position,
            5 => BindCoordinate::Size,
            6 => BindCoordinate::All,
            value => BindCoordinate::__Unknown(value),
        }
    }
}

impl StaticType for BindCoordinate {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_bind_coordinate_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BindCoordinate {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BindCoordinate {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BindCoordinate {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ContentGravity {
    TopLeft,
    Top,
    TopRight,
    Left,
    Center,
    Right,
    BottomLeft,
    Bottom,
    BottomRight,
    ResizeFill,
    ResizeAspect,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ContentGravity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ContentGravity::{}",
            match *self {
                ContentGravity::TopLeft => "TopLeft",
                ContentGravity::Top => "Top",
                ContentGravity::TopRight => "TopRight",
                ContentGravity::Left => "Left",
                ContentGravity::Center => "Center",
                ContentGravity::Right => "Right",
                ContentGravity::BottomLeft => "BottomLeft",
                ContentGravity::Bottom => "Bottom",
                ContentGravity::BottomRight => "BottomRight",
                ContentGravity::ResizeFill => "ResizeFill",
                ContentGravity::ResizeAspect => "ResizeAspect",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ContentGravity {
    type GlibType = ffi::ClutterContentGravity;

    fn to_glib(&self) -> ffi::ClutterContentGravity {
        match *self {
            ContentGravity::TopLeft => ffi::CLUTTER_CONTENT_GRAVITY_TOP_LEFT,
            ContentGravity::Top => ffi::CLUTTER_CONTENT_GRAVITY_TOP,
            ContentGravity::TopRight => ffi::CLUTTER_CONTENT_GRAVITY_TOP_RIGHT,
            ContentGravity::Left => ffi::CLUTTER_CONTENT_GRAVITY_LEFT,
            ContentGravity::Center => ffi::CLUTTER_CONTENT_GRAVITY_CENTER,
            ContentGravity::Right => ffi::CLUTTER_CONTENT_GRAVITY_RIGHT,
            ContentGravity::BottomLeft => ffi::CLUTTER_CONTENT_GRAVITY_BOTTOM_LEFT,
            ContentGravity::Bottom => ffi::CLUTTER_CONTENT_GRAVITY_BOTTOM,
            ContentGravity::BottomRight => ffi::CLUTTER_CONTENT_GRAVITY_BOTTOM_RIGHT,
            ContentGravity::ResizeFill => ffi::CLUTTER_CONTENT_GRAVITY_RESIZE_FILL,
            ContentGravity::ResizeAspect => ffi::CLUTTER_CONTENT_GRAVITY_RESIZE_ASPECT,
            ContentGravity::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterContentGravity> for ContentGravity {
    fn from_glib(value: ffi::ClutterContentGravity) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ContentGravity::TopLeft,
            1 => ContentGravity::Top,
            2 => ContentGravity::TopRight,
            3 => ContentGravity::Left,
            4 => ContentGravity::Center,
            5 => ContentGravity::Right,
            6 => ContentGravity::BottomLeft,
            7 => ContentGravity::Bottom,
            8 => ContentGravity::BottomRight,
            9 => ContentGravity::ResizeFill,
            10 => ContentGravity::ResizeAspect,
            value => ContentGravity::__Unknown(value),
        }
    }
}

impl StaticType for ContentGravity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_content_gravity_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ContentGravity {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ContentGravity {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ContentGravity {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DragAxis {
    AxisNone,
    XAxis,
    YAxis,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DragAxis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DragAxis::{}",
            match *self {
                DragAxis::AxisNone => "AxisNone",
                DragAxis::XAxis => "XAxis",
                DragAxis::YAxis => "YAxis",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DragAxis {
    type GlibType = ffi::ClutterDragAxis;

    fn to_glib(&self) -> ffi::ClutterDragAxis {
        match *self {
            DragAxis::AxisNone => ffi::CLUTTER_DRAG_AXIS_NONE,
            DragAxis::XAxis => ffi::CLUTTER_DRAG_X_AXIS,
            DragAxis::YAxis => ffi::CLUTTER_DRAG_Y_AXIS,
            DragAxis::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterDragAxis> for DragAxis {
    fn from_glib(value: ffi::ClutterDragAxis) -> Self {
        skip_assert_initialized!();
        match value {
            0 => DragAxis::AxisNone,
            1 => DragAxis::XAxis,
            2 => DragAxis::YAxis,
            value => DragAxis::__Unknown(value),
        }
    }
}

impl StaticType for DragAxis {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_drag_axis_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DragAxis {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DragAxis {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DragAxis {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EventType {
    Nothing,
    KeyPress,
    KeyRelease,
    Motion,
    Enter,
    Leave,
    ButtonPress,
    ButtonRelease,
    Scroll,
    StageState,
    DestroyNotify,
    ClientMessage,
    Delete,
    TouchBegin,
    TouchUpdate,
    TouchEnd,
    TouchCancel,
    TouchpadPinch,
    TouchpadSwipe,
    EventLast,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EventType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EventType::{}",
            match *self {
                EventType::Nothing => "Nothing",
                EventType::KeyPress => "KeyPress",
                EventType::KeyRelease => "KeyRelease",
                EventType::Motion => "Motion",
                EventType::Enter => "Enter",
                EventType::Leave => "Leave",
                EventType::ButtonPress => "ButtonPress",
                EventType::ButtonRelease => "ButtonRelease",
                EventType::Scroll => "Scroll",
                EventType::StageState => "StageState",
                EventType::DestroyNotify => "DestroyNotify",
                EventType::ClientMessage => "ClientMessage",
                EventType::Delete => "Delete",
                EventType::TouchBegin => "TouchBegin",
                EventType::TouchUpdate => "TouchUpdate",
                EventType::TouchEnd => "TouchEnd",
                EventType::TouchCancel => "TouchCancel",
                EventType::TouchpadPinch => "TouchpadPinch",
                EventType::TouchpadSwipe => "TouchpadSwipe",
                EventType::EventLast => "EventLast",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EventType {
    type GlibType = ffi::ClutterEventType;

    fn to_glib(&self) -> ffi::ClutterEventType {
        match *self {
            EventType::Nothing => ffi::CLUTTER_NOTHING,
            EventType::KeyPress => ffi::CLUTTER_KEY_PRESS,
            EventType::KeyRelease => ffi::CLUTTER_KEY_RELEASE,
            EventType::Motion => ffi::CLUTTER_MOTION,
            EventType::Enter => ffi::CLUTTER_ENTER,
            EventType::Leave => ffi::CLUTTER_LEAVE,
            EventType::ButtonPress => ffi::CLUTTER_BUTTON_PRESS,
            EventType::ButtonRelease => ffi::CLUTTER_BUTTON_RELEASE,
            EventType::Scroll => ffi::CLUTTER_SCROLL,
            EventType::StageState => ffi::CLUTTER_STAGE_STATE,
            EventType::DestroyNotify => ffi::CLUTTER_DESTROY_NOTIFY,
            EventType::ClientMessage => ffi::CLUTTER_CLIENT_MESSAGE,
            EventType::Delete => ffi::CLUTTER_DELETE,
            EventType::TouchBegin => ffi::CLUTTER_TOUCH_BEGIN,
            EventType::TouchUpdate => ffi::CLUTTER_TOUCH_UPDATE,
            EventType::TouchEnd => ffi::CLUTTER_TOUCH_END,
            EventType::TouchCancel => ffi::CLUTTER_TOUCH_CANCEL,
            EventType::TouchpadPinch => ffi::CLUTTER_TOUCHPAD_PINCH,
            EventType::TouchpadSwipe => ffi::CLUTTER_TOUCHPAD_SWIPE,
            EventType::EventLast => ffi::CLUTTER_EVENT_LAST,
            EventType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterEventType> for EventType {
    fn from_glib(value: ffi::ClutterEventType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => EventType::Nothing,
            1 => EventType::KeyPress,
            2 => EventType::KeyRelease,
            3 => EventType::Motion,
            4 => EventType::Enter,
            5 => EventType::Leave,
            6 => EventType::ButtonPress,
            7 => EventType::ButtonRelease,
            8 => EventType::Scroll,
            9 => EventType::StageState,
            10 => EventType::DestroyNotify,
            11 => EventType::ClientMessage,
            12 => EventType::Delete,
            13 => EventType::TouchBegin,
            14 => EventType::TouchUpdate,
            15 => EventType::TouchEnd,
            16 => EventType::TouchCancel,
            17 => EventType::TouchpadPinch,
            18 => EventType::TouchpadSwipe,
            19 => EventType::EventLast,
            value => EventType::__Unknown(value),
        }
    }
}

impl StaticType for EventType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_event_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EventType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EventType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EventType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FlowOrientation {
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FlowOrientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FlowOrientation::{}",
            match *self {
                FlowOrientation::Horizontal => "Horizontal",
                FlowOrientation::Vertical => "Vertical",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FlowOrientation {
    type GlibType = ffi::ClutterFlowOrientation;

    fn to_glib(&self) -> ffi::ClutterFlowOrientation {
        match *self {
            FlowOrientation::Horizontal => ffi::CLUTTER_FLOW_HORIZONTAL,
            FlowOrientation::Vertical => ffi::CLUTTER_FLOW_VERTICAL,
            FlowOrientation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterFlowOrientation> for FlowOrientation {
    fn from_glib(value: ffi::ClutterFlowOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FlowOrientation::Horizontal,
            1 => FlowOrientation::Vertical,
            value => FlowOrientation::__Unknown(value),
        }
    }
}

impl StaticType for FlowOrientation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_flow_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FlowOrientation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FlowOrientation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FlowOrientation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GestureTriggerEdge {
    None,
    After,
    Before,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for GestureTriggerEdge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "GestureTriggerEdge::{}",
            match *self {
                GestureTriggerEdge::None => "None",
                GestureTriggerEdge::After => "After",
                GestureTriggerEdge::Before => "Before",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for GestureTriggerEdge {
    type GlibType = ffi::ClutterGestureTriggerEdge;

    fn to_glib(&self) -> ffi::ClutterGestureTriggerEdge {
        match *self {
            GestureTriggerEdge::None => ffi::CLUTTER_GESTURE_TRIGGER_EDGE_NONE,
            GestureTriggerEdge::After => ffi::CLUTTER_GESTURE_TRIGGER_EDGE_AFTER,
            GestureTriggerEdge::Before => ffi::CLUTTER_GESTURE_TRIGGER_EDGE_BEFORE,
            GestureTriggerEdge::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterGestureTriggerEdge> for GestureTriggerEdge {
    fn from_glib(value: ffi::ClutterGestureTriggerEdge) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GestureTriggerEdge::None,
            1 => GestureTriggerEdge::After,
            2 => GestureTriggerEdge::Before,
            value => GestureTriggerEdge::__Unknown(value),
        }
    }
}

impl StaticType for GestureTriggerEdge {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_gesture_trigger_edge_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GestureTriggerEdge {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GestureTriggerEdge {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GestureTriggerEdge {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GridPosition {
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for GridPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "GridPosition::{}",
            match *self {
                GridPosition::Left => "Left",
                GridPosition::Right => "Right",
                GridPosition::Top => "Top",
                GridPosition::Bottom => "Bottom",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for GridPosition {
    type GlibType = ffi::ClutterGridPosition;

    fn to_glib(&self) -> ffi::ClutterGridPosition {
        match *self {
            GridPosition::Left => ffi::CLUTTER_GRID_POSITION_LEFT,
            GridPosition::Right => ffi::CLUTTER_GRID_POSITION_RIGHT,
            GridPosition::Top => ffi::CLUTTER_GRID_POSITION_TOP,
            GridPosition::Bottom => ffi::CLUTTER_GRID_POSITION_BOTTOM,
            GridPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterGridPosition> for GridPosition {
    fn from_glib(value: ffi::ClutterGridPosition) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GridPosition::Left,
            1 => GridPosition::Right,
            2 => GridPosition::Top,
            3 => GridPosition::Bottom,
            value => GridPosition::__Unknown(value),
        }
    }
}

impl StaticType for GridPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_grid_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GridPosition {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GridPosition {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GridPosition {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum InputAxis {
    Ignore,
    X,
    Y,
    Pressure,
    Xtilt,
    Ytilt,
    Wheel,
    Distance,
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputAxis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputAxis::{}",
            match *self {
                InputAxis::Ignore => "Ignore",
                InputAxis::X => "X",
                InputAxis::Y => "Y",
                InputAxis::Pressure => "Pressure",
                InputAxis::Xtilt => "Xtilt",
                InputAxis::Ytilt => "Ytilt",
                InputAxis::Wheel => "Wheel",
                InputAxis::Distance => "Distance",
                InputAxis::Last => "Last",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InputAxis {
    type GlibType = ffi::ClutterInputAxis;

    fn to_glib(&self) -> ffi::ClutterInputAxis {
        match *self {
            InputAxis::Ignore => ffi::CLUTTER_INPUT_AXIS_IGNORE,
            InputAxis::X => ffi::CLUTTER_INPUT_AXIS_X,
            InputAxis::Y => ffi::CLUTTER_INPUT_AXIS_Y,
            InputAxis::Pressure => ffi::CLUTTER_INPUT_AXIS_PRESSURE,
            InputAxis::Xtilt => ffi::CLUTTER_INPUT_AXIS_XTILT,
            InputAxis::Ytilt => ffi::CLUTTER_INPUT_AXIS_YTILT,
            InputAxis::Wheel => ffi::CLUTTER_INPUT_AXIS_WHEEL,
            InputAxis::Distance => ffi::CLUTTER_INPUT_AXIS_DISTANCE,
            InputAxis::Last => ffi::CLUTTER_INPUT_AXIS_LAST,
            InputAxis::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterInputAxis> for InputAxis {
    fn from_glib(value: ffi::ClutterInputAxis) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputAxis::Ignore,
            1 => InputAxis::X,
            2 => InputAxis::Y,
            3 => InputAxis::Pressure,
            4 => InputAxis::Xtilt,
            5 => InputAxis::Ytilt,
            6 => InputAxis::Wheel,
            7 => InputAxis::Distance,
            8 => InputAxis::Last,
            value => InputAxis::__Unknown(value),
        }
    }
}

impl StaticType for InputAxis {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_input_axis_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputAxis {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputAxis {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputAxis {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum InputDeviceType {
    PointerDevice,
    KeyboardDevice,
    ExtensionDevice,
    JoystickDevice,
    TabletDevice,
    TouchpadDevice,
    TouchscreenDevice,
    PenDevice,
    EraserDevice,
    CursorDevice,
    NDeviceTypes,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputDeviceType::{}",
            match *self {
                InputDeviceType::PointerDevice => "PointerDevice",
                InputDeviceType::KeyboardDevice => "KeyboardDevice",
                InputDeviceType::ExtensionDevice => "ExtensionDevice",
                InputDeviceType::JoystickDevice => "JoystickDevice",
                InputDeviceType::TabletDevice => "TabletDevice",
                InputDeviceType::TouchpadDevice => "TouchpadDevice",
                InputDeviceType::TouchscreenDevice => "TouchscreenDevice",
                InputDeviceType::PenDevice => "PenDevice",
                InputDeviceType::EraserDevice => "EraserDevice",
                InputDeviceType::CursorDevice => "CursorDevice",
                InputDeviceType::NDeviceTypes => "NDeviceTypes",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InputDeviceType {
    type GlibType = ffi::ClutterInputDeviceType;

    fn to_glib(&self) -> ffi::ClutterInputDeviceType {
        match *self {
            InputDeviceType::PointerDevice => ffi::CLUTTER_POINTER_DEVICE,
            InputDeviceType::KeyboardDevice => ffi::CLUTTER_KEYBOARD_DEVICE,
            InputDeviceType::ExtensionDevice => ffi::CLUTTER_EXTENSION_DEVICE,
            InputDeviceType::JoystickDevice => ffi::CLUTTER_JOYSTICK_DEVICE,
            InputDeviceType::TabletDevice => ffi::CLUTTER_TABLET_DEVICE,
            InputDeviceType::TouchpadDevice => ffi::CLUTTER_TOUCHPAD_DEVICE,
            InputDeviceType::TouchscreenDevice => ffi::CLUTTER_TOUCHSCREEN_DEVICE,
            InputDeviceType::PenDevice => ffi::CLUTTER_PEN_DEVICE,
            InputDeviceType::EraserDevice => ffi::CLUTTER_ERASER_DEVICE,
            InputDeviceType::CursorDevice => ffi::CLUTTER_CURSOR_DEVICE,
            InputDeviceType::NDeviceTypes => ffi::CLUTTER_N_DEVICE_TYPES,
            InputDeviceType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterInputDeviceType> for InputDeviceType {
    fn from_glib(value: ffi::ClutterInputDeviceType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputDeviceType::PointerDevice,
            1 => InputDeviceType::KeyboardDevice,
            2 => InputDeviceType::ExtensionDevice,
            3 => InputDeviceType::JoystickDevice,
            4 => InputDeviceType::TabletDevice,
            5 => InputDeviceType::TouchpadDevice,
            6 => InputDeviceType::TouchscreenDevice,
            7 => InputDeviceType::PenDevice,
            8 => InputDeviceType::EraserDevice,
            9 => InputDeviceType::CursorDevice,
            10 => InputDeviceType::NDeviceTypes,
            value => InputDeviceType::__Unknown(value),
        }
    }
}

impl StaticType for InputDeviceType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_input_device_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputDeviceType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputDeviceType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputDeviceType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum InputMode {
    Master,
    Slave,
    Floating,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "InputMode::{}",
            match *self {
                InputMode::Master => "Master",
                InputMode::Slave => "Slave",
                InputMode::Floating => "Floating",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for InputMode {
    type GlibType = ffi::ClutterInputMode;

    fn to_glib(&self) -> ffi::ClutterInputMode {
        match *self {
            InputMode::Master => ffi::CLUTTER_INPUT_MODE_MASTER,
            InputMode::Slave => ffi::CLUTTER_INPUT_MODE_SLAVE,
            InputMode::Floating => ffi::CLUTTER_INPUT_MODE_FLOATING,
            InputMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterInputMode> for InputMode {
    fn from_glib(value: ffi::ClutterInputMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputMode::Master,
            1 => InputMode::Slave,
            2 => InputMode::Floating,
            value => InputMode::__Unknown(value),
        }
    }
}

impl StaticType for InputMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_input_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum LongPressState {
    Query,
    Activate,
    Cancel,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LongPressState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LongPressState::{}",
            match *self {
                LongPressState::Query => "Query",
                LongPressState::Activate => "Activate",
                LongPressState::Cancel => "Cancel",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for LongPressState {
    type GlibType = ffi::ClutterLongPressState;

    fn to_glib(&self) -> ffi::ClutterLongPressState {
        match *self {
            LongPressState::Query => ffi::CLUTTER_LONG_PRESS_QUERY,
            LongPressState::Activate => ffi::CLUTTER_LONG_PRESS_ACTIVATE,
            LongPressState::Cancel => ffi::CLUTTER_LONG_PRESS_CANCEL,
            LongPressState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterLongPressState> for LongPressState {
    fn from_glib(value: ffi::ClutterLongPressState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LongPressState::Query,
            1 => LongPressState::Activate,
            2 => LongPressState::Cancel,
            value => LongPressState::__Unknown(value),
        }
    }
}

impl StaticType for LongPressState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_long_press_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LongPressState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LongPressState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LongPressState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Orientation {
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Orientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orientation::{}",
            match *self {
                Orientation::Horizontal => "Horizontal",
                Orientation::Vertical => "Vertical",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Orientation {
    type GlibType = ffi::ClutterOrientation;

    fn to_glib(&self) -> ffi::ClutterOrientation {
        match *self {
            Orientation::Horizontal => ffi::CLUTTER_ORIENTATION_HORIZONTAL,
            Orientation::Vertical => ffi::CLUTTER_ORIENTATION_VERTICAL,
            Orientation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterOrientation> for Orientation {
    fn from_glib(value: ffi::ClutterOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Orientation::Horizontal,
            1 => Orientation::Vertical,
            value => Orientation::__Unknown(value),
        }
    }
}

impl StaticType for Orientation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Orientation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Orientation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Orientation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PanAxis {
    AxisNone,
    XAxis,
    YAxis,
    AxisAuto,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PanAxis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PanAxis::{}",
            match *self {
                PanAxis::AxisNone => "AxisNone",
                PanAxis::XAxis => "XAxis",
                PanAxis::YAxis => "YAxis",
                PanAxis::AxisAuto => "AxisAuto",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PanAxis {
    type GlibType = ffi::ClutterPanAxis;

    fn to_glib(&self) -> ffi::ClutterPanAxis {
        match *self {
            PanAxis::AxisNone => ffi::CLUTTER_PAN_AXIS_NONE,
            PanAxis::XAxis => ffi::CLUTTER_PAN_X_AXIS,
            PanAxis::YAxis => ffi::CLUTTER_PAN_Y_AXIS,
            PanAxis::AxisAuto => ffi::CLUTTER_PAN_AXIS_AUTO,
            PanAxis::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterPanAxis> for PanAxis {
    fn from_glib(value: ffi::ClutterPanAxis) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PanAxis::AxisNone,
            1 => PanAxis::XAxis,
            2 => PanAxis::YAxis,
            3 => PanAxis::AxisAuto,
            value => PanAxis::__Unknown(value),
        }
    }
}

impl StaticType for PanAxis {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_pan_axis_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PanAxis {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PanAxis {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PanAxis {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PickMode {
    None,
    Reactive,
    All,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PickMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PickMode::{}",
            match *self {
                PickMode::None => "None",
                PickMode::Reactive => "Reactive",
                PickMode::All => "All",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PickMode {
    type GlibType = ffi::ClutterPickMode;

    fn to_glib(&self) -> ffi::ClutterPickMode {
        match *self {
            PickMode::None => ffi::CLUTTER_PICK_NONE,
            PickMode::Reactive => ffi::CLUTTER_PICK_REACTIVE,
            PickMode::All => ffi::CLUTTER_PICK_ALL,
            PickMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterPickMode> for PickMode {
    fn from_glib(value: ffi::ClutterPickMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PickMode::None,
            1 => PickMode::Reactive,
            2 => PickMode::All,
            value => PickMode::__Unknown(value),
        }
    }
}

impl StaticType for PickMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_pick_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PickMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PickMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PickMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RequestMode {
    HeightForWidth,
    WidthForHeight,
    ContentSize,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RequestMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RequestMode::{}",
            match *self {
                RequestMode::HeightForWidth => "HeightForWidth",
                RequestMode::WidthForHeight => "WidthForHeight",
                RequestMode::ContentSize => "ContentSize",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RequestMode {
    type GlibType = ffi::ClutterRequestMode;

    fn to_glib(&self) -> ffi::ClutterRequestMode {
        match *self {
            RequestMode::HeightForWidth => ffi::CLUTTER_REQUEST_HEIGHT_FOR_WIDTH,
            RequestMode::WidthForHeight => ffi::CLUTTER_REQUEST_WIDTH_FOR_HEIGHT,
            RequestMode::ContentSize => ffi::CLUTTER_REQUEST_CONTENT_SIZE,
            RequestMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterRequestMode> for RequestMode {
    fn from_glib(value: ffi::ClutterRequestMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RequestMode::HeightForWidth,
            1 => RequestMode::WidthForHeight,
            2 => RequestMode::ContentSize,
            value => RequestMode::__Unknown(value),
        }
    }
}

impl StaticType for RequestMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_request_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RequestMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RequestMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RequestMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RotateAxis {
    XAxis,
    YAxis,
    ZAxis,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RotateAxis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RotateAxis::{}",
            match *self {
                RotateAxis::XAxis => "XAxis",
                RotateAxis::YAxis => "YAxis",
                RotateAxis::ZAxis => "ZAxis",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RotateAxis {
    type GlibType = ffi::ClutterRotateAxis;

    fn to_glib(&self) -> ffi::ClutterRotateAxis {
        match *self {
            RotateAxis::XAxis => ffi::CLUTTER_X_AXIS,
            RotateAxis::YAxis => ffi::CLUTTER_Y_AXIS,
            RotateAxis::ZAxis => ffi::CLUTTER_Z_AXIS,
            RotateAxis::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterRotateAxis> for RotateAxis {
    fn from_glib(value: ffi::ClutterRotateAxis) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RotateAxis::XAxis,
            1 => RotateAxis::YAxis,
            2 => RotateAxis::ZAxis,
            value => RotateAxis::__Unknown(value),
        }
    }
}

impl StaticType for RotateAxis {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_rotate_axis_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RotateAxis {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RotateAxis {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RotateAxis {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RotateDirection {
    Cw,
    Ccw,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RotateDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RotateDirection::{}",
            match *self {
                RotateDirection::Cw => "Cw",
                RotateDirection::Ccw => "Ccw",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RotateDirection {
    type GlibType = ffi::ClutterRotateDirection;

    fn to_glib(&self) -> ffi::ClutterRotateDirection {
        match *self {
            RotateDirection::Cw => ffi::CLUTTER_ROTATE_CW,
            RotateDirection::Ccw => ffi::CLUTTER_ROTATE_CCW,
            RotateDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterRotateDirection> for RotateDirection {
    fn from_glib(value: ffi::ClutterRotateDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RotateDirection::Cw,
            1 => RotateDirection::Ccw,
            value => RotateDirection::__Unknown(value),
        }
    }
}

impl StaticType for RotateDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_rotate_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RotateDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RotateDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RotateDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScalingFilter {
    Linear,
    Nearest,
    Trilinear,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScalingFilter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScalingFilter::{}",
            match *self {
                ScalingFilter::Linear => "Linear",
                ScalingFilter::Nearest => "Nearest",
                ScalingFilter::Trilinear => "Trilinear",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScalingFilter {
    type GlibType = ffi::ClutterScalingFilter;

    fn to_glib(&self) -> ffi::ClutterScalingFilter {
        match *self {
            ScalingFilter::Linear => ffi::CLUTTER_SCALING_FILTER_LINEAR,
            ScalingFilter::Nearest => ffi::CLUTTER_SCALING_FILTER_NEAREST,
            ScalingFilter::Trilinear => ffi::CLUTTER_SCALING_FILTER_TRILINEAR,
            ScalingFilter::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterScalingFilter> for ScalingFilter {
    fn from_glib(value: ffi::ClutterScalingFilter) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScalingFilter::Linear,
            1 => ScalingFilter::Nearest,
            2 => ScalingFilter::Trilinear,
            value => ScalingFilter::__Unknown(value),
        }
    }
}

impl StaticType for ScalingFilter {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_scaling_filter_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScalingFilter {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScalingFilter {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScalingFilter {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScrollDirection {
    Up,
    Down,
    Left,
    Right,
    Smooth,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScrollDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollDirection::{}",
            match *self {
                ScrollDirection::Up => "Up",
                ScrollDirection::Down => "Down",
                ScrollDirection::Left => "Left",
                ScrollDirection::Right => "Right",
                ScrollDirection::Smooth => "Smooth",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScrollDirection {
    type GlibType = ffi::ClutterScrollDirection;

    fn to_glib(&self) -> ffi::ClutterScrollDirection {
        match *self {
            ScrollDirection::Up => ffi::CLUTTER_SCROLL_UP,
            ScrollDirection::Down => ffi::CLUTTER_SCROLL_DOWN,
            ScrollDirection::Left => ffi::CLUTTER_SCROLL_LEFT,
            ScrollDirection::Right => ffi::CLUTTER_SCROLL_RIGHT,
            ScrollDirection::Smooth => ffi::CLUTTER_SCROLL_SMOOTH,
            ScrollDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterScrollDirection> for ScrollDirection {
    fn from_glib(value: ffi::ClutterScrollDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollDirection::Up,
            1 => ScrollDirection::Down,
            2 => ScrollDirection::Left,
            3 => ScrollDirection::Right,
            4 => ScrollDirection::Smooth,
            value => ScrollDirection::__Unknown(value),
        }
    }
}

impl StaticType for ScrollDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_scroll_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScrollDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScrollDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScrollDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ShaderType {
    VertexShader,
    FragmentShader,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ShaderType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ShaderType::{}",
            match *self {
                ShaderType::VertexShader => "VertexShader",
                ShaderType::FragmentShader => "FragmentShader",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ShaderType {
    type GlibType = ffi::ClutterShaderType;

    fn to_glib(&self) -> ffi::ClutterShaderType {
        match *self {
            ShaderType::VertexShader => ffi::CLUTTER_VERTEX_SHADER,
            ShaderType::FragmentShader => ffi::CLUTTER_FRAGMENT_SHADER,
            ShaderType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterShaderType> for ShaderType {
    fn from_glib(value: ffi::ClutterShaderType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ShaderType::VertexShader,
            1 => ShaderType::FragmentShader,
            value => ShaderType::__Unknown(value),
        }
    }
}

impl StaticType for ShaderType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_shader_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ShaderType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ShaderType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ShaderType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SnapEdge {
    Top,
    Right,
    Bottom,
    Left,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SnapEdge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SnapEdge::{}",
            match *self {
                SnapEdge::Top => "Top",
                SnapEdge::Right => "Right",
                SnapEdge::Bottom => "Bottom",
                SnapEdge::Left => "Left",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SnapEdge {
    type GlibType = ffi::ClutterSnapEdge;

    fn to_glib(&self) -> ffi::ClutterSnapEdge {
        match *self {
            SnapEdge::Top => ffi::CLUTTER_SNAP_EDGE_TOP,
            SnapEdge::Right => ffi::CLUTTER_SNAP_EDGE_RIGHT,
            SnapEdge::Bottom => ffi::CLUTTER_SNAP_EDGE_BOTTOM,
            SnapEdge::Left => ffi::CLUTTER_SNAP_EDGE_LEFT,
            SnapEdge::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterSnapEdge> for SnapEdge {
    fn from_glib(value: ffi::ClutterSnapEdge) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SnapEdge::Top,
            1 => SnapEdge::Right,
            2 => SnapEdge::Bottom,
            3 => SnapEdge::Left,
            value => SnapEdge::__Unknown(value),
        }
    }
}

impl StaticType for SnapEdge {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_snap_edge_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapEdge {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapEdge {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapEdge {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum StaticColor {
    White,
    Black,
    Red,
    DarkRed,
    Green,
    DarkGreen,
    Blue,
    DarkBlue,
    Cyan,
    DarkCyan,
    Magenta,
    DarkMagenta,
    Yellow,
    DarkYellow,
    Gray,
    DarkGray,
    LightGray,
    Butter,
    ButterLight,
    ButterDark,
    Orange,
    OrangeLight,
    OrangeDark,
    Chocolate,
    ChocolateLight,
    ChocolateDark,
    Chameleon,
    ChameleonLight,
    ChameleonDark,
    SkyBlue,
    SkyBlueLight,
    SkyBlueDark,
    Plum,
    PlumLight,
    PlumDark,
    ScarletRed,
    ScarletRedLight,
    ScarletRedDark,
    Aluminium1,
    Aluminium2,
    Aluminium3,
    Aluminium4,
    Aluminium5,
    Aluminium6,
    Transparent,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StaticColor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StaticColor::{}",
            match *self {
                StaticColor::White => "White",
                StaticColor::Black => "Black",
                StaticColor::Red => "Red",
                StaticColor::DarkRed => "DarkRed",
                StaticColor::Green => "Green",
                StaticColor::DarkGreen => "DarkGreen",
                StaticColor::Blue => "Blue",
                StaticColor::DarkBlue => "DarkBlue",
                StaticColor::Cyan => "Cyan",
                StaticColor::DarkCyan => "DarkCyan",
                StaticColor::Magenta => "Magenta",
                StaticColor::DarkMagenta => "DarkMagenta",
                StaticColor::Yellow => "Yellow",
                StaticColor::DarkYellow => "DarkYellow",
                StaticColor::Gray => "Gray",
                StaticColor::DarkGray => "DarkGray",
                StaticColor::LightGray => "LightGray",
                StaticColor::Butter => "Butter",
                StaticColor::ButterLight => "ButterLight",
                StaticColor::ButterDark => "ButterDark",
                StaticColor::Orange => "Orange",
                StaticColor::OrangeLight => "OrangeLight",
                StaticColor::OrangeDark => "OrangeDark",
                StaticColor::Chocolate => "Chocolate",
                StaticColor::ChocolateLight => "ChocolateLight",
                StaticColor::ChocolateDark => "ChocolateDark",
                StaticColor::Chameleon => "Chameleon",
                StaticColor::ChameleonLight => "ChameleonLight",
                StaticColor::ChameleonDark => "ChameleonDark",
                StaticColor::SkyBlue => "SkyBlue",
                StaticColor::SkyBlueLight => "SkyBlueLight",
                StaticColor::SkyBlueDark => "SkyBlueDark",
                StaticColor::Plum => "Plum",
                StaticColor::PlumLight => "PlumLight",
                StaticColor::PlumDark => "PlumDark",
                StaticColor::ScarletRed => "ScarletRed",
                StaticColor::ScarletRedLight => "ScarletRedLight",
                StaticColor::ScarletRedDark => "ScarletRedDark",
                StaticColor::Aluminium1 => "Aluminium1",
                StaticColor::Aluminium2 => "Aluminium2",
                StaticColor::Aluminium3 => "Aluminium3",
                StaticColor::Aluminium4 => "Aluminium4",
                StaticColor::Aluminium5 => "Aluminium5",
                StaticColor::Aluminium6 => "Aluminium6",
                StaticColor::Transparent => "Transparent",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StaticColor {
    type GlibType = ffi::ClutterStaticColor;

    fn to_glib(&self) -> ffi::ClutterStaticColor {
        match *self {
            StaticColor::White => ffi::CLUTTER_COLOR_WHITE,
            StaticColor::Black => ffi::CLUTTER_COLOR_BLACK,
            StaticColor::Red => ffi::CLUTTER_COLOR_RED,
            StaticColor::DarkRed => ffi::CLUTTER_COLOR_DARK_RED,
            StaticColor::Green => ffi::CLUTTER_COLOR_GREEN,
            StaticColor::DarkGreen => ffi::CLUTTER_COLOR_DARK_GREEN,
            StaticColor::Blue => ffi::CLUTTER_COLOR_BLUE,
            StaticColor::DarkBlue => ffi::CLUTTER_COLOR_DARK_BLUE,
            StaticColor::Cyan => ffi::CLUTTER_COLOR_CYAN,
            StaticColor::DarkCyan => ffi::CLUTTER_COLOR_DARK_CYAN,
            StaticColor::Magenta => ffi::CLUTTER_COLOR_MAGENTA,
            StaticColor::DarkMagenta => ffi::CLUTTER_COLOR_DARK_MAGENTA,
            StaticColor::Yellow => ffi::CLUTTER_COLOR_YELLOW,
            StaticColor::DarkYellow => ffi::CLUTTER_COLOR_DARK_YELLOW,
            StaticColor::Gray => ffi::CLUTTER_COLOR_GRAY,
            StaticColor::DarkGray => ffi::CLUTTER_COLOR_DARK_GRAY,
            StaticColor::LightGray => ffi::CLUTTER_COLOR_LIGHT_GRAY,
            StaticColor::Butter => ffi::CLUTTER_COLOR_BUTTER,
            StaticColor::ButterLight => ffi::CLUTTER_COLOR_BUTTER_LIGHT,
            StaticColor::ButterDark => ffi::CLUTTER_COLOR_BUTTER_DARK,
            StaticColor::Orange => ffi::CLUTTER_COLOR_ORANGE,
            StaticColor::OrangeLight => ffi::CLUTTER_COLOR_ORANGE_LIGHT,
            StaticColor::OrangeDark => ffi::CLUTTER_COLOR_ORANGE_DARK,
            StaticColor::Chocolate => ffi::CLUTTER_COLOR_CHOCOLATE,
            StaticColor::ChocolateLight => ffi::CLUTTER_COLOR_CHOCOLATE_LIGHT,
            StaticColor::ChocolateDark => ffi::CLUTTER_COLOR_CHOCOLATE_DARK,
            StaticColor::Chameleon => ffi::CLUTTER_COLOR_CHAMELEON,
            StaticColor::ChameleonLight => ffi::CLUTTER_COLOR_CHAMELEON_LIGHT,
            StaticColor::ChameleonDark => ffi::CLUTTER_COLOR_CHAMELEON_DARK,
            StaticColor::SkyBlue => ffi::CLUTTER_COLOR_SKY_BLUE,
            StaticColor::SkyBlueLight => ffi::CLUTTER_COLOR_SKY_BLUE_LIGHT,
            StaticColor::SkyBlueDark => ffi::CLUTTER_COLOR_SKY_BLUE_DARK,
            StaticColor::Plum => ffi::CLUTTER_COLOR_PLUM,
            StaticColor::PlumLight => ffi::CLUTTER_COLOR_PLUM_LIGHT,
            StaticColor::PlumDark => ffi::CLUTTER_COLOR_PLUM_DARK,
            StaticColor::ScarletRed => ffi::CLUTTER_COLOR_SCARLET_RED,
            StaticColor::ScarletRedLight => ffi::CLUTTER_COLOR_SCARLET_RED_LIGHT,
            StaticColor::ScarletRedDark => ffi::CLUTTER_COLOR_SCARLET_RED_DARK,
            StaticColor::Aluminium1 => ffi::CLUTTER_COLOR_ALUMINIUM_1,
            StaticColor::Aluminium2 => ffi::CLUTTER_COLOR_ALUMINIUM_2,
            StaticColor::Aluminium3 => ffi::CLUTTER_COLOR_ALUMINIUM_3,
            StaticColor::Aluminium4 => ffi::CLUTTER_COLOR_ALUMINIUM_4,
            StaticColor::Aluminium5 => ffi::CLUTTER_COLOR_ALUMINIUM_5,
            StaticColor::Aluminium6 => ffi::CLUTTER_COLOR_ALUMINIUM_6,
            StaticColor::Transparent => ffi::CLUTTER_COLOR_TRANSPARENT,
            StaticColor::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterStaticColor> for StaticColor {
    fn from_glib(value: ffi::ClutterStaticColor) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StaticColor::White,
            1 => StaticColor::Black,
            2 => StaticColor::Red,
            3 => StaticColor::DarkRed,
            4 => StaticColor::Green,
            5 => StaticColor::DarkGreen,
            6 => StaticColor::Blue,
            7 => StaticColor::DarkBlue,
            8 => StaticColor::Cyan,
            9 => StaticColor::DarkCyan,
            10 => StaticColor::Magenta,
            11 => StaticColor::DarkMagenta,
            12 => StaticColor::Yellow,
            13 => StaticColor::DarkYellow,
            14 => StaticColor::Gray,
            15 => StaticColor::DarkGray,
            16 => StaticColor::LightGray,
            17 => StaticColor::Butter,
            18 => StaticColor::ButterLight,
            19 => StaticColor::ButterDark,
            20 => StaticColor::Orange,
            21 => StaticColor::OrangeLight,
            22 => StaticColor::OrangeDark,
            23 => StaticColor::Chocolate,
            24 => StaticColor::ChocolateLight,
            25 => StaticColor::ChocolateDark,
            26 => StaticColor::Chameleon,
            27 => StaticColor::ChameleonLight,
            28 => StaticColor::ChameleonDark,
            29 => StaticColor::SkyBlue,
            30 => StaticColor::SkyBlueLight,
            31 => StaticColor::SkyBlueDark,
            32 => StaticColor::Plum,
            33 => StaticColor::PlumLight,
            34 => StaticColor::PlumDark,
            35 => StaticColor::ScarletRed,
            36 => StaticColor::ScarletRedLight,
            37 => StaticColor::ScarletRedDark,
            38 => StaticColor::Aluminium1,
            39 => StaticColor::Aluminium2,
            40 => StaticColor::Aluminium3,
            41 => StaticColor::Aluminium4,
            42 => StaticColor::Aluminium5,
            43 => StaticColor::Aluminium6,
            44 => StaticColor::Transparent,
            value => StaticColor::__Unknown(value),
        }
    }
}

impl StaticType for StaticColor {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_static_color_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StaticColor {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StaticColor {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StaticColor {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum StepMode {
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StepMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StepMode::{}",
            match *self {
                StepMode::Start => "Start",
                StepMode::End => "End",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StepMode {
    type GlibType = ffi::ClutterStepMode;

    fn to_glib(&self) -> ffi::ClutterStepMode {
        match *self {
            StepMode::Start => ffi::CLUTTER_STEP_MODE_START,
            StepMode::End => ffi::CLUTTER_STEP_MODE_END,
            StepMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterStepMode> for StepMode {
    fn from_glib(value: ffi::ClutterStepMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StepMode::Start,
            1 => StepMode::End,
            value => StepMode::__Unknown(value),
        }
    }
}

impl StaticType for StepMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_step_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StepMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StepMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StepMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextDirection {
    Default,
    Ltr,
    Rtl,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextDirection::{}",
            match *self {
                TextDirection::Default => "Default",
                TextDirection::Ltr => "Ltr",
                TextDirection::Rtl => "Rtl",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextDirection {
    type GlibType = ffi::ClutterTextDirection;

    fn to_glib(&self) -> ffi::ClutterTextDirection {
        match *self {
            TextDirection::Default => ffi::CLUTTER_TEXT_DIRECTION_DEFAULT,
            TextDirection::Ltr => ffi::CLUTTER_TEXT_DIRECTION_LTR,
            TextDirection::Rtl => ffi::CLUTTER_TEXT_DIRECTION_RTL,
            TextDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterTextDirection> for TextDirection {
    fn from_glib(value: ffi::ClutterTextDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextDirection::Default,
            1 => TextDirection::Ltr,
            2 => TextDirection::Rtl,
            value => TextDirection::__Unknown(value),
        }
    }
}

impl StaticType for TextDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_text_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextureQuality {
    Low,
    Medium,
    High,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextureQuality {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextureQuality::{}",
            match *self {
                TextureQuality::Low => "Low",
                TextureQuality::Medium => "Medium",
                TextureQuality::High => "High",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextureQuality {
    type GlibType = ffi::ClutterTextureQuality;

    fn to_glib(&self) -> ffi::ClutterTextureQuality {
        match *self {
            TextureQuality::Low => ffi::CLUTTER_TEXTURE_QUALITY_LOW,
            TextureQuality::Medium => ffi::CLUTTER_TEXTURE_QUALITY_MEDIUM,
            TextureQuality::High => ffi::CLUTTER_TEXTURE_QUALITY_HIGH,
            TextureQuality::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterTextureQuality> for TextureQuality {
    fn from_glib(value: ffi::ClutterTextureQuality) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextureQuality::Low,
            1 => TextureQuality::Medium,
            2 => TextureQuality::High,
            value => TextureQuality::__Unknown(value),
        }
    }
}

impl StaticType for TextureQuality {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_texture_quality_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextureQuality {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextureQuality {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextureQuality {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TimelineDirection {
    Forward,
    Backward,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TimelineDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TimelineDirection::{}",
            match *self {
                TimelineDirection::Forward => "Forward",
                TimelineDirection::Backward => "Backward",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TimelineDirection {
    type GlibType = ffi::ClutterTimelineDirection;

    fn to_glib(&self) -> ffi::ClutterTimelineDirection {
        match *self {
            TimelineDirection::Forward => ffi::CLUTTER_TIMELINE_FORWARD,
            TimelineDirection::Backward => ffi::CLUTTER_TIMELINE_BACKWARD,
            TimelineDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterTimelineDirection> for TimelineDirection {
    fn from_glib(value: ffi::ClutterTimelineDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TimelineDirection::Forward,
            1 => TimelineDirection::Backward,
            value => TimelineDirection::__Unknown(value),
        }
    }
}

impl StaticType for TimelineDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_timeline_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TimelineDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TimelineDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TimelineDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ZoomAxis {
    XAxis,
    YAxis,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ZoomAxis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ZoomAxis::{}",
            match *self {
                ZoomAxis::XAxis => "XAxis",
                ZoomAxis::YAxis => "YAxis",
                ZoomAxis::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ZoomAxis {
    type GlibType = ffi::ClutterZoomAxis;

    fn to_glib(&self) -> ffi::ClutterZoomAxis {
        match *self {
            ZoomAxis::XAxis => ffi::CLUTTER_ZOOM_X_AXIS,
            ZoomAxis::YAxis => ffi::CLUTTER_ZOOM_Y_AXIS,
            ZoomAxis::Both => ffi::CLUTTER_ZOOM_BOTH,
            ZoomAxis::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClutterZoomAxis> for ZoomAxis {
    fn from_glib(value: ffi::ClutterZoomAxis) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ZoomAxis::XAxis,
            1 => ZoomAxis::YAxis,
            2 => ZoomAxis::Both,
            value => ZoomAxis::__Unknown(value),
        }
    }
}

impl StaticType for ZoomAxis {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::clutter_zoom_axis_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ZoomAxis {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ZoomAxis {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ZoomAxis {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
