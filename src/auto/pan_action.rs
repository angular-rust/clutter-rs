// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use super::Action;
use super::Actor;
use super::ActorMeta;
use super::GestureAction;
use super::PanAxis;
use ffi;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib_wrapper! {
    pub struct PanAction(Object<ffi::ClutterPanAction, ffi::ClutterPanActionClass, PanActionClass>) @extends GestureAction, Action, ActorMeta;

    match fn {
        get_type => || ffi::clutter_pan_action_get_type(),
    }
}

impl PanAction {
    pub fn new() -> PanAction {
        assert_initialized_main_thread!();
        unsafe { Action::from_glib_none(ffi::clutter_pan_action_new()).unsafe_cast() }
    }
}

impl Default for PanAction {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_PAN_ACTION: Option<&PanAction> = None;

pub trait PanActionExt: 'static {
    fn get_acceleration_factor(&self) -> f64;

    fn get_constrained_motion_delta(&self, point: u32) -> (f32, f32, f32);

    fn get_deceleration(&self) -> f64;

    fn get_interpolate(&self) -> bool;

    fn get_interpolated_coords(&self) -> (f32, f32);

    fn get_interpolated_delta(&self) -> (f32, f32, f32);

    fn get_pan_axis(&self) -> PanAxis;

    fn set_acceleration_factor(&self, factor: f64);

    fn set_deceleration(&self, rate: f64);

    fn set_interpolate(&self, should_interpolate: bool);

    fn set_pan_axis(&self, axis: PanAxis);

    fn connect_pan<F: Fn(&Self, &Actor, bool) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_pan_stopped<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_acceleration_factor_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_deceleration_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_interpolate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pan_axis_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<PanAction>> PanActionExt for O {
    fn get_acceleration_factor(&self) -> f64 {
        unsafe { ffi::clutter_pan_action_get_acceleration_factor(self.as_ref().to_glib_none().0) }
    }

    fn get_constrained_motion_delta(&self, point: u32) -> (f32, f32, f32) {
        unsafe {
            let mut delta_x = mem::MaybeUninit::uninit();
            let mut delta_y = mem::MaybeUninit::uninit();
            let ret = ffi::clutter_pan_action_get_constrained_motion_delta(
                self.as_ref().to_glib_none().0,
                point,
                delta_x.as_mut_ptr(),
                delta_y.as_mut_ptr(),
            );
            let delta_x = delta_x.assume_init();
            let delta_y = delta_y.assume_init();
            (ret, delta_x, delta_y)
        }
    }

    fn get_deceleration(&self) -> f64 {
        unsafe { ffi::clutter_pan_action_get_deceleration(self.as_ref().to_glib_none().0) }
    }

    fn get_interpolate(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_pan_action_get_interpolate(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_interpolated_coords(&self) -> (f32, f32) {
        unsafe {
            let mut interpolated_x = mem::MaybeUninit::uninit();
            let mut interpolated_y = mem::MaybeUninit::uninit();
            ffi::clutter_pan_action_get_interpolated_coords(
                self.as_ref().to_glib_none().0,
                interpolated_x.as_mut_ptr(),
                interpolated_y.as_mut_ptr(),
            );
            let interpolated_x = interpolated_x.assume_init();
            let interpolated_y = interpolated_y.assume_init();
            (interpolated_x, interpolated_y)
        }
    }

    fn get_interpolated_delta(&self) -> (f32, f32, f32) {
        unsafe {
            let mut delta_x = mem::MaybeUninit::uninit();
            let mut delta_y = mem::MaybeUninit::uninit();
            let ret = ffi::clutter_pan_action_get_interpolated_delta(
                self.as_ref().to_glib_none().0,
                delta_x.as_mut_ptr(),
                delta_y.as_mut_ptr(),
            );
            let delta_x = delta_x.assume_init();
            let delta_y = delta_y.assume_init();
            (ret, delta_x, delta_y)
        }
    }

    fn get_pan_axis(&self) -> PanAxis {
        unsafe {
            from_glib(ffi::clutter_pan_action_get_pan_axis(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn set_acceleration_factor(&self, factor: f64) {
        unsafe {
            ffi::clutter_pan_action_set_acceleration_factor(self.as_ref().to_glib_none().0, factor);
        }
    }

    fn set_deceleration(&self, rate: f64) {
        unsafe {
            ffi::clutter_pan_action_set_deceleration(self.as_ref().to_glib_none().0, rate);
        }
    }

    fn set_interpolate(&self, should_interpolate: bool) {
        unsafe {
            ffi::clutter_pan_action_set_interpolate(
                self.as_ref().to_glib_none().0,
                should_interpolate.to_glib(),
            );
        }
    }

    fn set_pan_axis(&self, axis: PanAxis) {
        unsafe {
            ffi::clutter_pan_action_set_pan_axis(self.as_ref().to_glib_none().0, axis.to_glib());
        }
    }

    fn connect_pan<F: Fn(&Self, &Actor, bool) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn pan_trampoline<P, F: Fn(&P, &Actor, bool) -> bool + 'static>(
            this: *mut ffi::ClutterPanAction,
            actor: *mut ffi::ClutterActor,
            is_interpolated: glib_sys::gboolean,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<PanAction>,
        {
            let f: &F = &*(f as *const F);
            f(
                &PanAction::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(actor),
                from_glib(is_interpolated),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"pan\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    pan_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_pan_stopped<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn pan_stopped_trampoline<P, F: Fn(&P, &Actor) + 'static>(
            this: *mut ffi::ClutterPanAction,
            actor: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<PanAction>,
        {
            let f: &F = &*(f as *const F);
            f(
                &PanAction::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(actor),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"pan-stopped\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    pan_stopped_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_acceleration_factor_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_acceleration_factor_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterPanAction,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<PanAction>,
        {
            let f: &F = &*(f as *const F);
            f(&PanAction::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::acceleration-factor\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_acceleration_factor_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_deceleration_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_deceleration_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterPanAction,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<PanAction>,
        {
            let f: &F = &*(f as *const F);
            f(&PanAction::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::deceleration\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_deceleration_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_interpolate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interpolate_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterPanAction,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<PanAction>,
        {
            let f: &F = &*(f as *const F);
            f(&PanAction::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::interpolate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_interpolate_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_pan_axis_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pan_axis_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterPanAction,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<PanAction>,
        {
            let f: &F = &*(f as *const F);
            f(&PanAction::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pan-axis\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_pan_axis_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for PanAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PanAction")
    }
}
