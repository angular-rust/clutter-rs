// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use atk;
use cairo;
use ffi;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::value::SetValueOptional;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use libc;
use pango;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;
use super::Action;
use super::ActorAlign;
use super::ActorBox;
use super::ActorFlags;
use super::AllocationFlags;
use super::Animatable;
use super::AnimationMode;
use crate::ButtonEvent;
use super::Color;
use super::Constraint;
use super::Container;
use super::Content;
use super::ContentGravity;
use super::ContentRepeat;
use crate::CrossingEvent;
use super::Effect;
use crate::Event;
use crate::KeyEvent;
use super::LayoutManager;
use super::Margin;
use super::Matrix;
use crate::MotionEvent;
use super::OffscreenRedirect;
use super::Orientation;
use super::PaintVolume;
use super::Rect;
use super::RequestMode;
use super::RotateAxis;
use super::ScalingFilter;
use crate::ScrollEvent;
use super::Stage;
use super::TextDirection;
use super::Transition;
use super::Vertex;

glib_wrapper! {
    pub struct Actor(Object<ffi::ClutterActor, ffi::ClutterActorClass, ActorClass>) @implements Animatable, Container;

    match fn {
        get_type => || ffi::clutter_actor_get_type(),
    }
}

impl Actor {
    pub fn new() -> Actor {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::clutter_actor_new()) }
    }
}

impl Default for Actor {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_ACTOR: Option<&Actor> = None;

pub trait ActorExt: 'static {
    fn add_action<P: IsA<Action>>(&self, action: &P);

    fn add_action_with_name<P: IsA<Action>>(&self, name: &str, action: &P);

    fn add_child<P: IsA<Actor>>(&self, child: &P);

    fn add_constraint<P: IsA<Constraint>>(&self, constraint: &P);

    fn add_constraint_with_name<P: IsA<Constraint>>(&self, name: &str, constraint: &P);

    fn add_effect<P: IsA<Effect>>(&self, effect: &P);

    fn add_effect_with_name<P: IsA<Effect>>(&self, name: &str, effect: &P);

    fn add_transition<P: IsA<Transition>>(&self, name: &str, transition: &P);

    fn allocate(&self, box_: &ActorBox, flags: AllocationFlags);

    fn allocate_align_fill(
        &self,
        box_: &ActorBox,
        x_align: f64,
        y_align: f64,
        x_fill: bool,
        y_fill: bool,
        flags: AllocationFlags,
    );

    fn allocate_available_size(
        &self,
        x: f32,
        y: f32,
        available_width: f32,
        available_height: f32,
        flags: AllocationFlags,
    );

    fn allocate_preferred_size(&self, flags: AllocationFlags);

    fn apply_relative_transform_to_point<P: IsA<Actor>>(
        &self,
        ancestor: Option<&P>,
        point: &Vertex,
    ) -> Vertex;

    fn apply_transform_to_point(&self, point: &Vertex) -> Vertex;

    //fn bind_model<P: IsA<gio::ListModel>>(&self, model: Option<&P>, create_child_func: /*Unimplemented*/Fn(/*Ignored*/glib::Object) -> Actor, user_data: /*Unimplemented*/Option<Fundamental: Pointer>);

    //fn bind_model_with_properties<P: IsA<gio::ListModel>>(&self, model: &P, child_type: glib::types::Type, first_model_property: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs);

    fn clear_actions(&self);

    fn clear_constraints(&self);

    fn clear_effects(&self);

    fn contains<P: IsA<Actor>>(&self, descendant: &P) -> bool;

    fn continue_paint(&self);

    fn create_pango_context(&self) -> Option<pango::Context>;

    fn create_pango_layout(&self, text: Option<&str>) -> Option<pango::Layout>;

    fn destroy(&self);

    fn destroy_all_children(&self);

    fn event(&self, event: &Event, capture: bool) -> bool;

    //fn get_abs_allocation_vertices(&self, verts: /*Unimplemented*/FixedArray TypeId { ns_id: 1, id: 16 }; 4);

    fn get_accessible(&self) -> Option<atk::Object>;

    fn get_action(&self, name: &str) -> Option<Action>;

    fn get_actions(&self) -> Vec<Action>;

    fn get_allocation_box(&self) -> ActorBox;

    //fn get_allocation_vertices<P: IsA<Actor>>(&self, ancestor: Option<&P>, verts: /*Unimplemented*/FixedArray TypeId { ns_id: 1, id: 16 }; 4);

    fn get_background_color(&self) -> Color;

    fn get_child_at_index(&self, index_: i32) -> Option<Actor>;

    fn get_child_transform(&self) -> Matrix;

    fn get_children(&self) -> Vec<Actor>;

    fn get_clip(&self) -> (f32, f32, f32, f32);

    fn get_clip_to_allocation(&self) -> bool;

    fn get_constraint(&self, name: &str) -> Option<Constraint>;

    fn get_constraints(&self) -> Vec<Constraint>;

    fn get_content(&self) -> Option<Content>;

    fn get_content_box(&self) -> ActorBox;

    fn get_content_gravity(&self) -> ContentGravity;

    fn get_content_repeat(&self) -> ContentRepeat;

    fn get_content_scaling_filters(&self) -> (ScalingFilter, ScalingFilter);

    fn get_default_paint_volume(&self) -> Option<PaintVolume>;

    fn get_easing_delay(&self) -> u32;

    fn get_easing_duration(&self) -> u32;

    fn get_easing_mode(&self) -> AnimationMode;

    fn get_effect(&self, name: &str) -> Option<Effect>;

    fn get_effects(&self) -> Vec<Effect>;

    fn get_first_child(&self) -> Option<Actor>;

    fn get_fixed_position_set(&self) -> bool;

    fn get_flags(&self) -> ActorFlags;

    fn get_height(&self) -> f32;

    fn get_last_child(&self) -> Option<Actor>;

    fn get_layout_manager(&self) -> Option<LayoutManager>;

    fn get_margin(&self) -> Margin;

    fn get_margin_bottom(&self) -> f32;

    fn get_margin_left(&self) -> f32;

    fn get_margin_right(&self) -> f32;

    fn get_margin_top(&self) -> f32;

    fn get_n_children(&self) -> i32;

    fn get_name(&self) -> Option<GString>;

    fn get_next_sibling(&self) -> Option<Actor>;

    fn get_offscreen_redirect(&self) -> OffscreenRedirect;

    fn get_opacity(&self) -> u8;

    fn get_paint_box(&self) -> Option<ActorBox>;

    fn get_paint_opacity(&self) -> u8;

    fn get_paint_visibility(&self) -> bool;

    fn get_paint_volume(&self) -> Option<PaintVolume>;

    fn get_pango_context(&self) -> Option<pango::Context>;

    fn get_parent(&self) -> Option<Actor>;

    fn get_pivot_point(&self) -> (f32, f32);

    fn get_pivot_point_z(&self) -> f32;

    fn get_position(&self) -> (f32, f32);

    fn get_preferred_height(&self, for_width: f32) -> (f32, f32);

    fn get_preferred_size(&self) -> (f32, f32, f32, f32);

    fn get_preferred_width(&self, for_height: f32) -> (f32, f32);

    fn get_previous_sibling(&self) -> Option<Actor>;

    fn get_reactive(&self) -> bool;

    fn get_request_mode(&self) -> RequestMode;

    fn get_rotation_angle(&self, axis: RotateAxis) -> f64;

    fn get_scale(&self) -> (f64, f64);

    fn get_scale_z(&self) -> f64;

    fn get_size(&self) -> (f32, f32);

    fn get_stage(&self) -> Option<Stage>;

    fn get_text_direction(&self) -> TextDirection;

    fn get_transform(&self) -> Matrix;

    fn get_transformed_paint_volume<P: IsA<Actor>>(
        &self,
        relative_to_ancestor: &P,
    ) -> Option<PaintVolume>;

    fn get_transformed_position(&self) -> (f32, f32);

    fn get_transformed_size(&self) -> (f32, f32);

    fn get_transition(&self, name: &str) -> Option<Transition>;

    fn get_translation(&self) -> (f32, f32, f32);

    fn get_width(&self) -> f32;

    fn get_x(&self) -> f32;

    fn get_x_align(&self) -> ActorAlign;

    fn get_x_expand(&self) -> bool;

    fn get_y(&self) -> f32;

    fn get_y_align(&self) -> ActorAlign;

    fn get_y_expand(&self) -> bool;

    fn get_z_position(&self) -> f32;

    fn grab_key_focus(&self);

    fn has_actions(&self) -> bool;

    fn has_allocation(&self) -> bool;

    fn has_clip(&self) -> bool;

    fn has_constraints(&self) -> bool;

    fn has_effects(&self) -> bool;

    fn has_key_focus(&self) -> bool;

    fn has_overlaps(&self) -> bool;

    fn has_pointer(&self) -> bool;

    fn hide(&self);

    fn insert_child_above<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    fn insert_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32);

    fn insert_child_below<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    fn is_in_clone_paint(&self) -> bool;

    fn is_mapped(&self) -> bool;

    fn is_realized(&self) -> bool;

    fn is_rotated(&self) -> bool;

    fn is_scaled(&self) -> bool;

    fn is_visible(&self) -> bool;

    fn map(&self);

    fn move_by(&self, dx: f32, dy: f32);

    fn needs_expand(&self, orientation: Orientation) -> bool;

    fn paint(&self);

    fn queue_redraw(&self);

    fn queue_redraw_with_clip(&self, clip: Option<&cairo::RectangleInt>);

    fn queue_relayout(&self);

    fn remove_action<P: IsA<Action>>(&self, action: &P);

    fn remove_action_by_name(&self, name: &str);

    fn remove_all_children(&self);

    fn remove_all_transitions(&self);

    fn remove_child<P: IsA<Actor>>(&self, child: &P);

    fn remove_clip(&self);

    fn remove_constraint<P: IsA<Constraint>>(&self, constraint: &P);

    fn remove_constraint_by_name(&self, name: &str);

    fn remove_effect<P: IsA<Effect>>(&self, effect: &P);

    fn remove_effect_by_name(&self, name: &str);

    fn remove_transition(&self, name: &str);

    fn replace_child<P: IsA<Actor>, Q: IsA<Actor>>(&self, old_child: &P, new_child: &Q);

    fn restore_easing_state(&self);

    fn save_easing_state(&self);

    fn set_allocation(&self, box_: &ActorBox, flags: AllocationFlags);

    fn set_background_color(&self, color: Option<&Color>);

    fn set_child_above_sibling<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    fn set_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32);

    fn set_child_below_sibling<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>);

    fn set_child_transform(&self, transform: Option<&Matrix>);

    fn set_clip(&self, xoff: f32, yoff: f32, width: f32, height: f32);

    fn set_clip_to_allocation(&self, clip_set: bool);

    fn set_content<P: IsA<Content>>(&self, content: Option<&P>);

    fn set_content_gravity(&self, gravity: ContentGravity);

    fn set_content_repeat(&self, repeat: ContentRepeat);

    fn set_content_scaling_filters(&self, min_filter: ScalingFilter, mag_filter: ScalingFilter);

    fn set_easing_delay(&self, msecs: u32);

    fn set_easing_duration(&self, msecs: u32);

    fn set_easing_mode(&self, mode: AnimationMode);

    fn set_fixed_position_set(&self, is_set: bool);

    fn set_flags(&self, flags: ActorFlags);

    fn set_height(&self, height: f32);

    fn set_layout_manager<P: IsA<LayoutManager>>(&self, manager: Option<&P>);

    fn set_margin(&self, margin: &Margin);

    fn set_margin_bottom(&self, margin: f32);

    fn set_margin_left(&self, margin: f32);

    fn set_margin_right(&self, margin: f32);

    fn set_margin_top(&self, margin: f32);

    fn set_name(&self, name: &str);

    fn set_offscreen_redirect(&self, redirect: OffscreenRedirect);

    fn set_opacity(&self, opacity: u8);

    fn set_pivot_point(&self, pivot_x: f32, pivot_y: f32);

    fn set_pivot_point_z(&self, pivot_z: f32);

    fn set_position(&self, x: f32, y: f32);

    fn set_reactive(&self, reactive: bool);

    fn set_request_mode(&self, mode: RequestMode);

    fn set_rotation_angle(&self, axis: RotateAxis, angle: f64);

    fn set_scale(&self, scale_x: f64, scale_y: f64);

    fn set_scale_z(&self, scale_z: f64);

    fn set_size(&self, width: f32, height: f32);

    fn set_text_direction(&self, text_dir: TextDirection);

    fn set_transform(&self, transform: Option<&Matrix>);

    fn set_translation(&self, translate_x: f32, translate_y: f32, translate_z: f32);

    fn set_width(&self, width: f32);

    fn set_x(&self, x: f32);

    fn set_x_align(&self, x_align: ActorAlign);

    fn set_x_expand(&self, expand: bool);

    fn set_y(&self, y: f32);

    fn set_y_align(&self, y_align: ActorAlign);

    fn set_y_expand(&self, expand: bool);

    fn set_z_position(&self, z_position: f32);

    fn should_pick_paint(&self) -> bool;

    fn show(&self);

    fn transform_stage_point(&self, x: f32, y: f32) -> Option<(f32, f32)>;

    fn unmap(&self);

    fn unset_flags(&self, flags: ActorFlags);

    fn set_property_actions<P: IsA<Action> + SetValueOptional>(&self, actions: Option<&P>);

    fn get_property_allocation(&self) -> Option<ActorBox>;

    fn get_property_background_color_set(&self) -> bool;

    fn get_property_child_transform_set(&self) -> bool;

    fn get_property_clip_rect(&self) -> Option<Rect>;

    fn set_property_clip_rect(&self, clip_rect: Option<&Rect>);

    fn set_property_constraints<P: IsA<Constraint> + SetValueOptional>(
        &self,
        constraints: Option<&P>,
    );

    fn set_property_effect<P: IsA<Effect> + SetValueOptional>(&self, effect: Option<&P>);

    fn get_property_fixed_x(&self) -> f32;

    fn set_property_fixed_x(&self, fixed_x: f32);

    fn get_property_fixed_y(&self) -> f32;

    fn set_property_fixed_y(&self, fixed_y: f32);

    fn get_property_has_clip(&self) -> bool;

    fn get_property_has_pointer(&self) -> bool;

    fn get_property_magnification_filter(&self) -> ScalingFilter;

    fn set_property_magnification_filter(&self, magnification_filter: ScalingFilter);

    fn get_property_mapped(&self) -> bool;

    fn get_property_min_height(&self) -> f32;

    fn set_property_min_height(&self, min_height: f32);

    fn get_property_min_height_set(&self) -> bool;

    fn set_property_min_height_set(&self, min_height_set: bool);

    fn get_property_min_width(&self) -> f32;

    fn set_property_min_width(&self, min_width: f32);

    fn get_property_min_width_set(&self) -> bool;

    fn set_property_min_width_set(&self, min_width_set: bool);

    fn get_property_minification_filter(&self) -> ScalingFilter;

    fn set_property_minification_filter(&self, minification_filter: ScalingFilter);

    fn get_property_natural_height(&self) -> f32;

    fn set_property_natural_height(&self, natural_height: f32);

    fn get_property_natural_height_set(&self) -> bool;

    fn set_property_natural_height_set(&self, natural_height_set: bool);

    fn get_property_natural_width(&self) -> f32;

    fn set_property_natural_width(&self, natural_width: f32);

    fn get_property_natural_width_set(&self) -> bool;

    fn set_property_natural_width_set(&self, natural_width_set: bool);

    fn get_property_realized(&self) -> bool;

    fn get_property_rotation_angle_x(&self) -> f64;

    fn set_property_rotation_angle_x(&self, rotation_angle_x: f64);

    fn get_property_rotation_angle_y(&self) -> f64;

    fn set_property_rotation_angle_y(&self, rotation_angle_y: f64);

    fn get_property_rotation_angle_z(&self) -> f64;

    fn set_property_rotation_angle_z(&self, rotation_angle_z: f64);

    fn get_property_scale_x(&self) -> f64;

    fn set_property_scale_x(&self, scale_x: f64);

    fn get_property_scale_y(&self) -> f64;

    fn set_property_scale_y(&self, scale_y: f64);

    fn get_property_show_on_set_parent(&self) -> bool;

    fn set_property_show_on_set_parent(&self, show_on_set_parent: bool);

    fn get_property_transform_set(&self) -> bool;

    fn get_property_translation_x(&self) -> f32;

    fn set_property_translation_x(&self, translation_x: f32);

    fn get_property_translation_y(&self) -> f32;

    fn set_property_translation_y(&self, translation_y: f32);

    fn get_property_translation_z(&self) -> f32;

    fn set_property_translation_z(&self, translation_z: f32);

    fn get_property_visible(&self) -> bool;

    fn set_property_visible(&self, visible: bool);

    fn connect_allocation_changed<F: Fn(&Self, &ActorBox, AllocationFlags) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_button_press_event<F: Fn(&Self, &ButtonEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_button_release_event<F: Fn(&Self, &ButtonEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_captured_event<F: Fn(&Self, &Event) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_destroy<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_enter_event<F: Fn(&Self, &CrossingEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_event<F: Fn(&Self, &Event) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_hide<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_key_focus_in<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_key_focus_out<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_key_press_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_key_release_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_leave_event<F: Fn(&Self, &CrossingEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_motion_event<F: Fn(&Self, &MotionEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_parent_set<F: Fn(&Self, Option<&Actor>) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_queue_redraw<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_queue_relayout<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_scroll_event<F: Fn(&Self, &ScrollEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_show<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_touch_event<F: Fn(&Self, &Event) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_transition_stopped<F: Fn(&Self, &str, bool) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_transitions_completed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_actions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_allocation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_background_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_background_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_child_transform_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_child_transform_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_clip_rect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_clip_to_allocation_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_constraints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_content_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_content_box_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_content_gravity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_content_repeat_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_effect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_first_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_fixed_position_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_fixed_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_fixed_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_has_clip_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_has_pointer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_last_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_layout_manager_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_magnification_filter_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_mapped_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_margin_bottom_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_margin_left_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_margin_right_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_margin_top_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_min_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_min_height_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_min_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_min_width_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_minification_filter_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_natural_height_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_natural_height_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_natural_width_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_natural_width_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_offscreen_redirect_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_opacity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pivot_point_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pivot_point_z_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_reactive_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_realized_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_request_mode_notify<F: Fn(&Self) + 'static>(&self, f: F)
        -> SignalHandlerId;

    fn connect_property_rotation_angle_x_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_rotation_angle_y_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_rotation_angle_z_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_scale_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_scale_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_scale_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_show_on_set_parent_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_text_direction_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_transform_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_transform_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_translation_x_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_translation_y_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_translation_z_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    fn connect_property_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_x_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_x_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_y_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_y_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_z_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Actor>> ActorExt for O {
    fn add_action<P: IsA<Action>>(&self, action: &P) {
        unsafe {
            ffi::clutter_actor_add_action(
                self.as_ref().to_glib_none().0,
                action.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_action_with_name<P: IsA<Action>>(&self, name: &str, action: &P) {
        unsafe {
            ffi::clutter_actor_add_action_with_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
                action.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_child<P: IsA<Actor>>(&self, child: &P) {
        unsafe {
            ffi::clutter_actor_add_child(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_constraint<P: IsA<Constraint>>(&self, constraint: &P) {
        unsafe {
            ffi::clutter_actor_add_constraint(
                self.as_ref().to_glib_none().0,
                constraint.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_constraint_with_name<P: IsA<Constraint>>(&self, name: &str, constraint: &P) {
        unsafe {
            ffi::clutter_actor_add_constraint_with_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
                constraint.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_effect<P: IsA<Effect>>(&self, effect: &P) {
        unsafe {
            ffi::clutter_actor_add_effect(
                self.as_ref().to_glib_none().0,
                effect.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_effect_with_name<P: IsA<Effect>>(&self, name: &str, effect: &P) {
        unsafe {
            ffi::clutter_actor_add_effect_with_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
                effect.as_ref().to_glib_none().0,
            );
        }
    }

    fn add_transition<P: IsA<Transition>>(&self, name: &str, transition: &P) {
        unsafe {
            ffi::clutter_actor_add_transition(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
                transition.as_ref().to_glib_none().0,
            );
        }
    }

    fn allocate(&self, box_: &ActorBox, flags: AllocationFlags) {
        unsafe {
            ffi::clutter_actor_allocate(
                self.as_ref().to_glib_none().0,
                box_.to_glib_none().0,
                flags.to_glib(),
            );
        }
    }

    fn allocate_align_fill(
        &self,
        box_: &ActorBox,
        x_align: f64,
        y_align: f64,
        x_fill: bool,
        y_fill: bool,
        flags: AllocationFlags,
    ) {
        unsafe {
            ffi::clutter_actor_allocate_align_fill(
                self.as_ref().to_glib_none().0,
                box_.to_glib_none().0,
                x_align,
                y_align,
                x_fill.to_glib(),
                y_fill.to_glib(),
                flags.to_glib(),
            );
        }
    }

    fn allocate_available_size(
        &self,
        x: f32,
        y: f32,
        available_width: f32,
        available_height: f32,
        flags: AllocationFlags,
    ) {
        unsafe {
            ffi::clutter_actor_allocate_available_size(
                self.as_ref().to_glib_none().0,
                x,
                y,
                available_width,
                available_height,
                flags.to_glib(),
            );
        }
    }

    fn allocate_preferred_size(&self, flags: AllocationFlags) {
        unsafe {
            ffi::clutter_actor_allocate_preferred_size(
                self.as_ref().to_glib_none().0,
                flags.to_glib(),
            );
        }
    }

    fn apply_relative_transform_to_point<P: IsA<Actor>>(
        &self,
        ancestor: Option<&P>,
        point: &Vertex,
    ) -> Vertex {
        unsafe {
            let mut vertex = Vertex::uninitialized();
            ffi::clutter_actor_apply_relative_transform_to_point(
                self.as_ref().to_glib_none().0,
                ancestor.map(|p| p.as_ref()).to_glib_none().0,
                point.to_glib_none().0,
                vertex.to_glib_none_mut().0,
            );
            vertex
        }
    }

    fn apply_transform_to_point(&self, point: &Vertex) -> Vertex {
        unsafe {
            let mut vertex = Vertex::uninitialized();
            ffi::clutter_actor_apply_transform_to_point(
                self.as_ref().to_glib_none().0,
                point.to_glib_none().0,
                vertex.to_glib_none_mut().0,
            );
            vertex
        }
    }

    //fn bind_model<P: IsA<gio::ListModel>>(&self, model: Option<&P>, create_child_func: /*Unimplemented*/Fn(/*Ignored*/glib::Object) -> Actor, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call clutter_sys:clutter_actor_bind_model() }
    //}

    //fn bind_model_with_properties<P: IsA<gio::ListModel>>(&self, model: &P, child_type: glib::types::Type, first_model_property: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
    //    unsafe { TODO: call clutter_sys:clutter_actor_bind_model_with_properties() }
    //}

    fn clear_actions(&self) {
        unsafe {
            ffi::clutter_actor_clear_actions(self.as_ref().to_glib_none().0);
        }
    }

    fn clear_constraints(&self) {
        unsafe {
            ffi::clutter_actor_clear_constraints(self.as_ref().to_glib_none().0);
        }
    }

    fn clear_effects(&self) {
        unsafe {
            ffi::clutter_actor_clear_effects(self.as_ref().to_glib_none().0);
        }
    }

    fn contains<P: IsA<Actor>>(&self, descendant: &P) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_contains(
                self.as_ref().to_glib_none().0,
                descendant.as_ref().to_glib_none().0,
            ))
        }
    }

    fn continue_paint(&self) {
        unsafe {
            ffi::clutter_actor_continue_paint(self.as_ref().to_glib_none().0);
        }
    }

    fn create_pango_context(&self) -> Option<pango::Context> {
        unsafe {
            from_glib_full(ffi::clutter_actor_create_pango_context(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn create_pango_layout(&self, text: Option<&str>) -> Option<pango::Layout> {
        unsafe {
            from_glib_full(ffi::clutter_actor_create_pango_layout(
                self.as_ref().to_glib_none().0,
                text.to_glib_none().0,
            ))
        }
    }

    fn destroy(&self) {
        unsafe {
            ffi::clutter_actor_destroy(self.as_ref().to_glib_none().0);
        }
    }

    fn destroy_all_children(&self) {
        unsafe {
            ffi::clutter_actor_destroy_all_children(self.as_ref().to_glib_none().0);
        }
    }

    fn event(&self, event: &Event, capture: bool) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_event(
                self.as_ref().to_glib_none().0,
                event.to_glib_none().0,
                capture.to_glib(),
            ))
        }
    }

    //fn get_abs_allocation_vertices(&self, verts: /*Unimplemented*/FixedArray TypeId { ns_id: 1, id: 16 }; 4) {
    //    unsafe { TODO: call clutter_sys:clutter_actor_get_abs_allocation_vertices() }
    //}

    fn get_accessible(&self) -> Option<atk::Object> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_accessible(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_action(&self, name: &str) -> Option<Action> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_action(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    fn get_actions(&self) -> Vec<Action> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_actions(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_allocation_box(&self) -> ActorBox {
        unsafe {
            let mut box_ = ActorBox::uninitialized();
            ffi::clutter_actor_get_allocation_box(
                self.as_ref().to_glib_none().0,
                box_.to_glib_none_mut().0,
            );
            box_
        }
    }

    //fn get_allocation_vertices<P: IsA<Actor>>(&self, ancestor: Option<&P>, verts: /*Unimplemented*/FixedArray TypeId { ns_id: 1, id: 16 }; 4) {
    //    unsafe { TODO: call clutter_sys:clutter_actor_get_allocation_vertices() }
    //}

    fn get_background_color(&self) -> Color {
        unsafe {
            let mut color = Color::uninitialized();
            ffi::clutter_actor_get_background_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none_mut().0,
            );
            color
        }
    }

    fn get_child_at_index(&self, index_: i32) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_child_at_index(
                self.as_ref().to_glib_none().0,
                index_,
            ))
        }
    }

    fn get_child_transform(&self) -> Matrix {
        unsafe {
            let mut transform = Matrix::uninitialized();
            ffi::clutter_actor_get_child_transform(
                self.as_ref().to_glib_none().0,
                transform.to_glib_none_mut().0,
            );
            transform
        }
    }

    fn get_children(&self) -> Vec<Actor> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_children(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_clip(&self) -> (f32, f32, f32, f32) {
        unsafe {
            let mut xoff = mem::MaybeUninit::uninit();
            let mut yoff = mem::MaybeUninit::uninit();
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_clip(
                self.as_ref().to_glib_none().0,
                xoff.as_mut_ptr(),
                yoff.as_mut_ptr(),
                width.as_mut_ptr(),
                height.as_mut_ptr(),
            );
            let xoff = xoff.assume_init();
            let yoff = yoff.assume_init();
            let width = width.assume_init();
            let height = height.assume_init();
            (xoff, yoff, width, height)
        }
    }

    fn get_clip_to_allocation(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_clip_to_allocation(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_constraint(&self, name: &str) -> Option<Constraint> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_constraint(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    fn get_constraints(&self) -> Vec<Constraint> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_constraints(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_content(&self) -> Option<Content> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_content(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_content_box(&self) -> ActorBox {
        unsafe {
            let mut box_ = ActorBox::uninitialized();
            ffi::clutter_actor_get_content_box(
                self.as_ref().to_glib_none().0,
                box_.to_glib_none_mut().0,
            );
            box_
        }
    }

    fn get_content_gravity(&self) -> ContentGravity {
        unsafe {
            from_glib(ffi::clutter_actor_get_content_gravity(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_content_repeat(&self) -> ContentRepeat {
        unsafe {
            from_glib(ffi::clutter_actor_get_content_repeat(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_content_scaling_filters(&self) -> (ScalingFilter, ScalingFilter) {
        unsafe {
            let mut min_filter = mem::MaybeUninit::uninit();
            let mut mag_filter = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_content_scaling_filters(
                self.as_ref().to_glib_none().0,
                min_filter.as_mut_ptr(),
                mag_filter.as_mut_ptr(),
            );
            let min_filter = min_filter.assume_init();
            let mag_filter = mag_filter.assume_init();
            (from_glib(min_filter), from_glib(mag_filter))
        }
    }

    fn get_default_paint_volume(&self) -> Option<PaintVolume> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_default_paint_volume(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_easing_delay(&self) -> u32 {
        unsafe { ffi::clutter_actor_get_easing_delay(self.as_ref().to_glib_none().0) }
    }

    fn get_easing_duration(&self) -> u32 {
        unsafe { ffi::clutter_actor_get_easing_duration(self.as_ref().to_glib_none().0) }
    }

    fn get_easing_mode(&self) -> AnimationMode {
        unsafe {
            from_glib(ffi::clutter_actor_get_easing_mode(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_effect(&self, name: &str) -> Option<Effect> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_effect(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    fn get_effects(&self) -> Vec<Effect> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_actor_get_effects(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_first_child(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_first_child(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_fixed_position_set(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_fixed_position_set(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_flags(&self) -> ActorFlags {
        unsafe {
            from_glib(ffi::clutter_actor_get_flags(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_height(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_height(self.as_ref().to_glib_none().0) }
    }

    fn get_last_child(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_last_child(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_layout_manager(&self) -> Option<LayoutManager> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_layout_manager(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_margin(&self) -> Margin {
        unsafe {
            let mut margin = Margin::uninitialized();
            ffi::clutter_actor_get_margin(
                self.as_ref().to_glib_none().0,
                margin.to_glib_none_mut().0,
            );
            margin
        }
    }

    fn get_margin_bottom(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_margin_bottom(self.as_ref().to_glib_none().0) }
    }

    fn get_margin_left(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_margin_left(self.as_ref().to_glib_none().0) }
    }

    fn get_margin_right(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_margin_right(self.as_ref().to_glib_none().0) }
    }

    fn get_margin_top(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_margin_top(self.as_ref().to_glib_none().0) }
    }

    fn get_n_children(&self) -> i32 {
        unsafe { ffi::clutter_actor_get_n_children(self.as_ref().to_glib_none().0) }
    }

    fn get_name(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_name(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_next_sibling(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_next_sibling(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_offscreen_redirect(&self) -> OffscreenRedirect {
        unsafe {
            from_glib(ffi::clutter_actor_get_offscreen_redirect(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_opacity(&self) -> u8 {
        unsafe { ffi::clutter_actor_get_opacity(self.as_ref().to_glib_none().0) }
    }

    fn get_paint_box(&self) -> Option<ActorBox> {
        unsafe {
            let mut box_ = ActorBox::uninitialized();
            let ret = from_glib(ffi::clutter_actor_get_paint_box(
                self.as_ref().to_glib_none().0,
                box_.to_glib_none_mut().0,
            ));
            if ret {
                Some(box_)
            } else {
                None
            }
        }
    }

    fn get_paint_opacity(&self) -> u8 {
        unsafe { ffi::clutter_actor_get_paint_opacity(self.as_ref().to_glib_none().0) }
    }

    fn get_paint_visibility(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_paint_visibility(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_paint_volume(&self) -> Option<PaintVolume> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_paint_volume(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_pango_context(&self) -> Option<pango::Context> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_pango_context(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_parent(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_parent(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_pivot_point(&self) -> (f32, f32) {
        unsafe {
            let mut pivot_x = mem::MaybeUninit::uninit();
            let mut pivot_y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_pivot_point(
                self.as_ref().to_glib_none().0,
                pivot_x.as_mut_ptr(),
                pivot_y.as_mut_ptr(),
            );
            let pivot_x = pivot_x.assume_init();
            let pivot_y = pivot_y.assume_init();
            (pivot_x, pivot_y)
        }
    }

    fn get_pivot_point_z(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_pivot_point_z(self.as_ref().to_glib_none().0) }
    }

    fn get_position(&self) -> (f32, f32) {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_position(
                self.as_ref().to_glib_none().0,
                x.as_mut_ptr(),
                y.as_mut_ptr(),
            );
            let x = x.assume_init();
            let y = y.assume_init();
            (x, y)
        }
    }

    fn get_preferred_height(&self, for_width: f32) -> (f32, f32) {
        unsafe {
            let mut min_height_p = mem::MaybeUninit::uninit();
            let mut natural_height_p = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_preferred_height(
                self.as_ref().to_glib_none().0,
                for_width,
                min_height_p.as_mut_ptr(),
                natural_height_p.as_mut_ptr(),
            );
            let min_height_p = min_height_p.assume_init();
            let natural_height_p = natural_height_p.assume_init();
            (min_height_p, natural_height_p)
        }
    }

    fn get_preferred_size(&self) -> (f32, f32, f32, f32) {
        unsafe {
            let mut min_width_p = mem::MaybeUninit::uninit();
            let mut min_height_p = mem::MaybeUninit::uninit();
            let mut natural_width_p = mem::MaybeUninit::uninit();
            let mut natural_height_p = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_preferred_size(
                self.as_ref().to_glib_none().0,
                min_width_p.as_mut_ptr(),
                min_height_p.as_mut_ptr(),
                natural_width_p.as_mut_ptr(),
                natural_height_p.as_mut_ptr(),
            );
            let min_width_p = min_width_p.assume_init();
            let min_height_p = min_height_p.assume_init();
            let natural_width_p = natural_width_p.assume_init();
            let natural_height_p = natural_height_p.assume_init();
            (min_width_p, min_height_p, natural_width_p, natural_height_p)
        }
    }

    fn get_preferred_width(&self, for_height: f32) -> (f32, f32) {
        unsafe {
            let mut min_width_p = mem::MaybeUninit::uninit();
            let mut natural_width_p = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_preferred_width(
                self.as_ref().to_glib_none().0,
                for_height,
                min_width_p.as_mut_ptr(),
                natural_width_p.as_mut_ptr(),
            );
            let min_width_p = min_width_p.assume_init();
            let natural_width_p = natural_width_p.assume_init();
            (min_width_p, natural_width_p)
        }
    }

    fn get_previous_sibling(&self) -> Option<Actor> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_previous_sibling(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_reactive(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_reactive(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_request_mode(&self) -> RequestMode {
        unsafe {
            from_glib(ffi::clutter_actor_get_request_mode(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_rotation_angle(&self, axis: RotateAxis) -> f64 {
        unsafe {
            ffi::clutter_actor_get_rotation_angle(
                self.as_ref().to_glib_none().0,
                axis.to_glib(),
            )
        }
    }

    fn get_scale(&self) -> (f64, f64) {
        unsafe {
            let mut scale_x = mem::MaybeUninit::uninit();
            let mut scale_y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_scale(
                self.as_ref().to_glib_none().0,
                scale_x.as_mut_ptr(),
                scale_y.as_mut_ptr(),
            );
            let scale_x = scale_x.assume_init();
            let scale_y = scale_y.assume_init();
            (scale_x, scale_y)
        }
    }

    fn get_scale_z(&self) -> f64 {
        unsafe { ffi::clutter_actor_get_scale_z(self.as_ref().to_glib_none().0) }
    }

    fn get_size(&self) -> (f32, f32) {
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_size(
                self.as_ref().to_glib_none().0,
                width.as_mut_ptr(),
                height.as_mut_ptr(),
            );
            let width = width.assume_init();
            let height = height.assume_init();
            (width, height)
        }
    }

    fn get_stage(&self) -> Option<Stage> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_stage(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_text_direction(&self) -> TextDirection {
        unsafe {
            from_glib(ffi::clutter_actor_get_text_direction(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_transform(&self) -> Matrix {
        unsafe {
            let mut transform = Matrix::uninitialized();
            ffi::clutter_actor_get_transform(
                self.as_ref().to_glib_none().0,
                transform.to_glib_none_mut().0,
            );
            transform
        }
    }

    fn get_transformed_paint_volume<P: IsA<Actor>>(
        &self,
        relative_to_ancestor: &P,
    ) -> Option<PaintVolume> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_transformed_paint_volume(
                self.as_ref().to_glib_none().0,
                relative_to_ancestor.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_transformed_position(&self) -> (f32, f32) {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_transformed_position(
                self.as_ref().to_glib_none().0,
                x.as_mut_ptr(),
                y.as_mut_ptr(),
            );
            let x = x.assume_init();
            let y = y.assume_init();
            (x, y)
        }
    }

    fn get_transformed_size(&self) -> (f32, f32) {
        unsafe {
            let mut width = mem::MaybeUninit::uninit();
            let mut height = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_transformed_size(
                self.as_ref().to_glib_none().0,
                width.as_mut_ptr(),
                height.as_mut_ptr(),
            );
            let width = width.assume_init();
            let height = height.assume_init();
            (width, height)
        }
    }

    fn get_transition(&self, name: &str) -> Option<Transition> {
        unsafe {
            from_glib_none(ffi::clutter_actor_get_transition(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    fn get_translation(&self) -> (f32, f32, f32) {
        unsafe {
            let mut translate_x = mem::MaybeUninit::uninit();
            let mut translate_y = mem::MaybeUninit::uninit();
            let mut translate_z = mem::MaybeUninit::uninit();
            ffi::clutter_actor_get_translation(
                self.as_ref().to_glib_none().0,
                translate_x.as_mut_ptr(),
                translate_y.as_mut_ptr(),
                translate_z.as_mut_ptr(),
            );
            let translate_x = translate_x.assume_init();
            let translate_y = translate_y.assume_init();
            let translate_z = translate_z.assume_init();
            (translate_x, translate_y, translate_z)
        }
    }

    fn get_width(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_width(self.as_ref().to_glib_none().0) }
    }

    fn get_x(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_x(self.as_ref().to_glib_none().0) }
    }

    fn get_x_align(&self) -> ActorAlign {
        unsafe {
            from_glib(ffi::clutter_actor_get_x_align(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_x_expand(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_x_expand(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_y(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_y(self.as_ref().to_glib_none().0) }
    }

    fn get_y_align(&self) -> ActorAlign {
        unsafe {
            from_glib(ffi::clutter_actor_get_y_align(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_y_expand(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_get_y_expand(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_z_position(&self) -> f32 {
        unsafe { ffi::clutter_actor_get_z_position(self.as_ref().to_glib_none().0) }
    }

    fn grab_key_focus(&self) {
        unsafe {
            ffi::clutter_actor_grab_key_focus(self.as_ref().to_glib_none().0);
        }
    }

    fn has_actions(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_actions(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_allocation(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_allocation(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_clip(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_clip(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_constraints(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_constraints(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_effects(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_effects(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_key_focus(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_key_focus(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_overlaps(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_overlaps(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn has_pointer(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_has_pointer(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn hide(&self) {
        unsafe {
            ffi::clutter_actor_hide(self.as_ref().to_glib_none().0);
        }
    }

    fn insert_child_above<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>) {
        unsafe {
            ffi::clutter_actor_insert_child_above(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                sibling.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    fn insert_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32) {
        unsafe {
            ffi::clutter_actor_insert_child_at_index(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                index_,
            );
        }
    }

    fn insert_child_below<P: IsA<Actor>, Q: IsA<Actor>>(&self, child: &P, sibling: Option<&Q>) {
        unsafe {
            ffi::clutter_actor_insert_child_below(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                sibling.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    fn is_in_clone_paint(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_in_clone_paint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_mapped(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_mapped(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_realized(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_realized(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_rotated(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_rotated(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_scaled(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_scaled(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn is_visible(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_is_visible(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn map(&self) {
        unsafe {
            ffi::clutter_actor_map(self.as_ref().to_glib_none().0);
        }
    }

    fn move_by(&self, dx: f32, dy: f32) {
        unsafe {
            ffi::clutter_actor_move_by(self.as_ref().to_glib_none().0, dx, dy);
        }
    }

    fn needs_expand(&self, orientation: Orientation) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_needs_expand(
                self.as_ref().to_glib_none().0,
                orientation.to_glib(),
            ))
        }
    }

    fn paint(&self) {
        unsafe {
            ffi::clutter_actor_paint(self.as_ref().to_glib_none().0);
        }
    }

    fn queue_redraw(&self) {
        unsafe {
            ffi::clutter_actor_queue_redraw(self.as_ref().to_glib_none().0);
        }
    }

    fn queue_redraw_with_clip(&self, clip: Option<&cairo::RectangleInt>) {
        unsafe {
            ffi::clutter_actor_queue_redraw_with_clip(
                self.as_ref().to_glib_none().0,
                clip.to_glib_none().0,
            );
        }
    }

    fn queue_relayout(&self) {
        unsafe {
            ffi::clutter_actor_queue_relayout(self.as_ref().to_glib_none().0);
        }
    }

    fn remove_action<P: IsA<Action>>(&self, action: &P) {
        unsafe {
            ffi::clutter_actor_remove_action(
                self.as_ref().to_glib_none().0,
                action.as_ref().to_glib_none().0,
            );
        }
    }

    fn remove_action_by_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_action_by_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            );
        }
    }

    fn remove_all_children(&self) {
        unsafe {
            ffi::clutter_actor_remove_all_children(self.as_ref().to_glib_none().0);
        }
    }

    fn remove_all_transitions(&self) {
        unsafe {
            ffi::clutter_actor_remove_all_transitions(self.as_ref().to_glib_none().0);
        }
    }

    fn remove_child<P: IsA<Actor>>(&self, child: &P) {
        unsafe {
            ffi::clutter_actor_remove_child(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
            );
        }
    }

    fn remove_clip(&self) {
        unsafe {
            ffi::clutter_actor_remove_clip(self.as_ref().to_glib_none().0);
        }
    }

    fn remove_constraint<P: IsA<Constraint>>(&self, constraint: &P) {
        unsafe {
            ffi::clutter_actor_remove_constraint(
                self.as_ref().to_glib_none().0,
                constraint.as_ref().to_glib_none().0,
            );
        }
    }

    fn remove_constraint_by_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_constraint_by_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            );
        }
    }

    fn remove_effect<P: IsA<Effect>>(&self, effect: &P) {
        unsafe {
            ffi::clutter_actor_remove_effect(
                self.as_ref().to_glib_none().0,
                effect.as_ref().to_glib_none().0,
            );
        }
    }

    fn remove_effect_by_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_effect_by_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            );
        }
    }

    fn remove_transition(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_remove_transition(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            );
        }
    }

    fn replace_child<P: IsA<Actor>, Q: IsA<Actor>>(&self, old_child: &P, new_child: &Q) {
        unsafe {
            ffi::clutter_actor_replace_child(
                self.as_ref().to_glib_none().0,
                old_child.as_ref().to_glib_none().0,
                new_child.as_ref().to_glib_none().0,
            );
        }
    }

    fn restore_easing_state(&self) {
        unsafe {
            ffi::clutter_actor_restore_easing_state(self.as_ref().to_glib_none().0);
        }
    }

    fn save_easing_state(&self) {
        unsafe {
            ffi::clutter_actor_save_easing_state(self.as_ref().to_glib_none().0);
        }
    }

    fn set_allocation(&self, box_: &ActorBox, flags: AllocationFlags) {
        unsafe {
            ffi::clutter_actor_set_allocation(
                self.as_ref().to_glib_none().0,
                box_.to_glib_none().0,
                flags.to_glib(),
            );
        }
    }

    fn set_background_color(&self, color: Option<&Color>) {
        unsafe {
            ffi::clutter_actor_set_background_color(
                self.as_ref().to_glib_none().0,
                color.to_glib_none().0,
            );
        }
    }

    fn set_child_above_sibling<P: IsA<Actor>, Q: IsA<Actor>>(
        &self,
        child: &P,
        sibling: Option<&Q>,
    ) {
        unsafe {
            ffi::clutter_actor_set_child_above_sibling(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                sibling.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    fn set_child_at_index<P: IsA<Actor>>(&self, child: &P, index_: i32) {
        unsafe {
            ffi::clutter_actor_set_child_at_index(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                index_,
            );
        }
    }

    fn set_child_below_sibling<P: IsA<Actor>, Q: IsA<Actor>>(
        &self,
        child: &P,
        sibling: Option<&Q>,
    ) {
        unsafe {
            ffi::clutter_actor_set_child_below_sibling(
                self.as_ref().to_glib_none().0,
                child.as_ref().to_glib_none().0,
                sibling.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    fn set_child_transform(&self, transform: Option<&Matrix>) {
        unsafe {
            ffi::clutter_actor_set_child_transform(
                self.as_ref().to_glib_none().0,
                transform.to_glib_none().0,
            );
        }
    }

    fn set_clip(&self, xoff: f32, yoff: f32, width: f32, height: f32) {
        unsafe {
            ffi::clutter_actor_set_clip(
                self.as_ref().to_glib_none().0,
                xoff,
                yoff,
                width,
                height,
            );
        }
    }

    fn set_clip_to_allocation(&self, clip_set: bool) {
        unsafe {
            ffi::clutter_actor_set_clip_to_allocation(
                self.as_ref().to_glib_none().0,
                clip_set.to_glib(),
            );
        }
    }

    fn set_content<P: IsA<Content>>(&self, content: Option<&P>) {
        unsafe {
            ffi::clutter_actor_set_content(
                self.as_ref().to_glib_none().0,
                content.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    fn set_content_gravity(&self, gravity: ContentGravity) {
        unsafe {
            ffi::clutter_actor_set_content_gravity(
                self.as_ref().to_glib_none().0,
                gravity.to_glib(),
            );
        }
    }

    fn set_content_repeat(&self, repeat: ContentRepeat) {
        unsafe {
            ffi::clutter_actor_set_content_repeat(
                self.as_ref().to_glib_none().0,
                repeat.to_glib(),
            );
        }
    }

    fn set_content_scaling_filters(&self, min_filter: ScalingFilter, mag_filter: ScalingFilter) {
        unsafe {
            ffi::clutter_actor_set_content_scaling_filters(
                self.as_ref().to_glib_none().0,
                min_filter.to_glib(),
                mag_filter.to_glib(),
            );
        }
    }

    fn set_easing_delay(&self, msecs: u32) {
        unsafe {
            ffi::clutter_actor_set_easing_delay(self.as_ref().to_glib_none().0, msecs);
        }
    }

    fn set_easing_duration(&self, msecs: u32) {
        unsafe {
            ffi::clutter_actor_set_easing_duration(self.as_ref().to_glib_none().0, msecs);
        }
    }

    fn set_easing_mode(&self, mode: AnimationMode) {
        unsafe {
            ffi::clutter_actor_set_easing_mode(
                self.as_ref().to_glib_none().0,
                mode.to_glib(),
            );
        }
    }

    fn set_fixed_position_set(&self, is_set: bool) {
        unsafe {
            ffi::clutter_actor_set_fixed_position_set(
                self.as_ref().to_glib_none().0,
                is_set.to_glib(),
            );
        }
    }

    fn set_flags(&self, flags: ActorFlags) {
        unsafe {
            ffi::clutter_actor_set_flags(self.as_ref().to_glib_none().0, flags.to_glib());
        }
    }

    fn set_height(&self, height: f32) {
        unsafe {
            ffi::clutter_actor_set_height(self.as_ref().to_glib_none().0, height);
        }
    }

    fn set_layout_manager<P: IsA<LayoutManager>>(&self, manager: Option<&P>) {
        unsafe {
            ffi::clutter_actor_set_layout_manager(
                self.as_ref().to_glib_none().0,
                manager.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    fn set_margin(&self, margin: &Margin) {
        unsafe {
            ffi::clutter_actor_set_margin(
                self.as_ref().to_glib_none().0,
                margin.to_glib_none().0,
            );
        }
    }

    fn set_margin_bottom(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_bottom(self.as_ref().to_glib_none().0, margin);
        }
    }

    fn set_margin_left(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_left(self.as_ref().to_glib_none().0, margin);
        }
    }

    fn set_margin_right(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_right(self.as_ref().to_glib_none().0, margin);
        }
    }

    fn set_margin_top(&self, margin: f32) {
        unsafe {
            ffi::clutter_actor_set_margin_top(self.as_ref().to_glib_none().0, margin);
        }
    }

    fn set_name(&self, name: &str) {
        unsafe {
            ffi::clutter_actor_set_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            );
        }
    }

    fn set_offscreen_redirect(&self, redirect: OffscreenRedirect) {
        unsafe {
            ffi::clutter_actor_set_offscreen_redirect(
                self.as_ref().to_glib_none().0,
                redirect.to_glib(),
            );
        }
    }

    fn set_opacity(&self, opacity: u8) {
        unsafe {
            ffi::clutter_actor_set_opacity(self.as_ref().to_glib_none().0, opacity);
        }
    }

    fn set_pivot_point(&self, pivot_x: f32, pivot_y: f32) {
        unsafe {
            ffi::clutter_actor_set_pivot_point(
                self.as_ref().to_glib_none().0,
                pivot_x,
                pivot_y,
            );
        }
    }

    fn set_pivot_point_z(&self, pivot_z: f32) {
        unsafe {
            ffi::clutter_actor_set_pivot_point_z(self.as_ref().to_glib_none().0, pivot_z);
        }
    }

    fn set_position(&self, x: f32, y: f32) {
        unsafe {
            ffi::clutter_actor_set_position(self.as_ref().to_glib_none().0, x, y);
        }
    }

    fn set_reactive(&self, reactive: bool) {
        unsafe {
            ffi::clutter_actor_set_reactive(
                self.as_ref().to_glib_none().0,
                reactive.to_glib(),
            );
        }
    }

    fn set_request_mode(&self, mode: RequestMode) {
        unsafe {
            ffi::clutter_actor_set_request_mode(
                self.as_ref().to_glib_none().0,
                mode.to_glib(),
            );
        }
    }

    fn set_rotation_angle(&self, axis: RotateAxis, angle: f64) {
        unsafe {
            ffi::clutter_actor_set_rotation_angle(
                self.as_ref().to_glib_none().0,
                axis.to_glib(),
                angle,
            );
        }
    }

    fn set_scale(&self, scale_x: f64, scale_y: f64) {
        unsafe {
            ffi::clutter_actor_set_scale(self.as_ref().to_glib_none().0, scale_x, scale_y);
        }
    }

    fn set_scale_z(&self, scale_z: f64) {
        unsafe {
            ffi::clutter_actor_set_scale_z(self.as_ref().to_glib_none().0, scale_z);
        }
    }

    fn set_size(&self, width: f32, height: f32) {
        unsafe {
            ffi::clutter_actor_set_size(self.as_ref().to_glib_none().0, width, height);
        }
    }

    fn set_text_direction(&self, text_dir: TextDirection) {
        unsafe {
            ffi::clutter_actor_set_text_direction(
                self.as_ref().to_glib_none().0,
                text_dir.to_glib(),
            );
        }
    }

    fn set_transform(&self, transform: Option<&Matrix>) {
        unsafe {
            ffi::clutter_actor_set_transform(
                self.as_ref().to_glib_none().0,
                transform.to_glib_none().0,
            );
        }
    }

    fn set_translation(&self, translate_x: f32, translate_y: f32, translate_z: f32) {
        unsafe {
            ffi::clutter_actor_set_translation(
                self.as_ref().to_glib_none().0,
                translate_x,
                translate_y,
                translate_z,
            );
        }
    }

    fn set_width(&self, width: f32) {
        unsafe {
            ffi::clutter_actor_set_width(self.as_ref().to_glib_none().0, width);
        }
    }

    fn set_x(&self, x: f32) {
        unsafe {
            ffi::clutter_actor_set_x(self.as_ref().to_glib_none().0, x);
        }
    }

    fn set_x_align(&self, x_align: ActorAlign) {
        unsafe {
            ffi::clutter_actor_set_x_align(
                self.as_ref().to_glib_none().0,
                x_align.to_glib(),
            );
        }
    }

    fn set_x_expand(&self, expand: bool) {
        unsafe {
            ffi::clutter_actor_set_x_expand(
                self.as_ref().to_glib_none().0,
                expand.to_glib(),
            );
        }
    }

    fn set_y(&self, y: f32) {
        unsafe {
            ffi::clutter_actor_set_y(self.as_ref().to_glib_none().0, y);
        }
    }

    fn set_y_align(&self, y_align: ActorAlign) {
        unsafe {
            ffi::clutter_actor_set_y_align(
                self.as_ref().to_glib_none().0,
                y_align.to_glib(),
            );
        }
    }

    fn set_y_expand(&self, expand: bool) {
        unsafe {
            ffi::clutter_actor_set_y_expand(
                self.as_ref().to_glib_none().0,
                expand.to_glib(),
            );
        }
    }

    fn set_z_position(&self, z_position: f32) {
        unsafe {
            ffi::clutter_actor_set_z_position(self.as_ref().to_glib_none().0, z_position);
        }
    }

    fn should_pick_paint(&self) -> bool {
        unsafe {
            from_glib(ffi::clutter_actor_should_pick_paint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn show(&self) {
        unsafe {
            ffi::clutter_actor_show(self.as_ref().to_glib_none().0);
        }
    }

    fn transform_stage_point(&self, x: f32, y: f32) -> Option<(f32, f32)> {
        unsafe {
            let mut x_out = mem::MaybeUninit::uninit();
            let mut y_out = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::clutter_actor_transform_stage_point(
                self.as_ref().to_glib_none().0,
                x,
                y,
                x_out.as_mut_ptr(),
                y_out.as_mut_ptr(),
            ));
            let x_out = x_out.assume_init();
            let y_out = y_out.assume_init();
            if ret {
                Some((x_out, y_out))
            } else {
                None
            }
        }
    }

    fn unmap(&self) {
        unsafe {
            ffi::clutter_actor_unmap(self.as_ref().to_glib_none().0);
        }
    }

    fn unset_flags(&self, flags: ActorFlags) {
        unsafe {
            ffi::clutter_actor_unset_flags(self.as_ref().to_glib_none().0, flags.to_glib());
        }
    }

    fn set_property_actions<P: IsA<Action> + SetValueOptional>(&self, actions: Option<&P>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"actions\0".as_ptr() as *const _,
                Value::from(actions).to_glib_none().0,
            );
        }
    }

    fn get_property_allocation(&self) -> Option<ActorBox> {
        unsafe {
            let mut value = Value::from_type(<ActorBox as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"allocation\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `allocation` getter")
        }
    }

    fn get_property_background_color_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"background-color-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `background-color-set` getter")
                .unwrap()
        }
    }

    fn get_property_child_transform_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"child-transform-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `child-transform-set` getter")
                .unwrap()
        }
    }

    fn get_property_clip_rect(&self) -> Option<Rect> {
        unsafe {
            let mut value = Value::from_type(<Rect as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"clip-rect\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `clip-rect` getter")
        }
    }

    fn set_property_clip_rect(&self, clip_rect: Option<&Rect>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"clip-rect\0".as_ptr() as *const _,
                Value::from(clip_rect).to_glib_none().0,
            );
        }
    }

    fn set_property_constraints<P: IsA<Constraint> + SetValueOptional>(
        &self,
        constraints: Option<&P>,
    ) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"constraints\0".as_ptr() as *const _,
                Value::from(constraints).to_glib_none().0,
            );
        }
    }

    fn set_property_effect<P: IsA<Effect> + SetValueOptional>(&self, effect: Option<&P>) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"effect\0".as_ptr() as *const _,
                Value::from(effect).to_glib_none().0,
            );
        }
    }

    fn get_property_fixed_x(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"fixed-x\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `fixed-x` getter")
                .unwrap()
        }
    }

    fn set_property_fixed_x(&self, fixed_x: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"fixed-x\0".as_ptr() as *const _,
                Value::from(&fixed_x).to_glib_none().0,
            );
        }
    }

    fn get_property_fixed_y(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"fixed-y\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `fixed-y` getter")
                .unwrap()
        }
    }

    fn set_property_fixed_y(&self, fixed_y: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"fixed-y\0".as_ptr() as *const _,
                Value::from(&fixed_y).to_glib_none().0,
            );
        }
    }

    fn get_property_has_clip(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"has-clip\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `has-clip` getter")
                .unwrap()
        }
    }

    fn get_property_has_pointer(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"has-pointer\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `has-pointer` getter")
                .unwrap()
        }
    }

    fn get_property_magnification_filter(&self) -> ScalingFilter {
        unsafe {
            let mut value = Value::from_type(<ScalingFilter as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"magnification-filter\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `magnification-filter` getter")
                .unwrap()
        }
    }

    fn set_property_magnification_filter(&self, magnification_filter: ScalingFilter) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"magnification-filter\0".as_ptr() as *const _,
                Value::from(&magnification_filter).to_glib_none().0,
            );
        }
    }

    fn get_property_mapped(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"mapped\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `mapped` getter")
                .unwrap()
        }
    }

    fn get_property_min_height(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-height\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `min-height` getter")
                .unwrap()
        }
    }

    fn set_property_min_height(&self, min_height: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-height\0".as_ptr() as *const _,
                Value::from(&min_height).to_glib_none().0,
            );
        }
    }

    fn get_property_min_height_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-height-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `min-height-set` getter")
                .unwrap()
        }
    }

    fn set_property_min_height_set(&self, min_height_set: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-height-set\0".as_ptr() as *const _,
                Value::from(&min_height_set).to_glib_none().0,
            );
        }
    }

    fn get_property_min_width(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-width\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `min-width` getter")
                .unwrap()
        }
    }

    fn set_property_min_width(&self, min_width: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-width\0".as_ptr() as *const _,
                Value::from(&min_width).to_glib_none().0,
            );
        }
    }

    fn get_property_min_width_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-width-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `min-width-set` getter")
                .unwrap()
        }
    }

    fn set_property_min_width_set(&self, min_width_set: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"min-width-set\0".as_ptr() as *const _,
                Value::from(&min_width_set).to_glib_none().0,
            );
        }
    }

    fn get_property_minification_filter(&self) -> ScalingFilter {
        unsafe {
            let mut value = Value::from_type(<ScalingFilter as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"minification-filter\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `minification-filter` getter")
                .unwrap()
        }
    }

    fn set_property_minification_filter(&self, minification_filter: ScalingFilter) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"minification-filter\0".as_ptr() as *const _,
                Value::from(&minification_filter).to_glib_none().0,
            );
        }
    }

    fn get_property_natural_height(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-height\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `natural-height` getter")
                .unwrap()
        }
    }

    fn set_property_natural_height(&self, natural_height: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-height\0".as_ptr() as *const _,
                Value::from(&natural_height).to_glib_none().0,
            );
        }
    }

    fn get_property_natural_height_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-height-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `natural-height-set` getter")
                .unwrap()
        }
    }

    fn set_property_natural_height_set(&self, natural_height_set: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-height-set\0".as_ptr() as *const _,
                Value::from(&natural_height_set).to_glib_none().0,
            );
        }
    }

    fn get_property_natural_width(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-width\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `natural-width` getter")
                .unwrap()
        }
    }

    fn set_property_natural_width(&self, natural_width: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-width\0".as_ptr() as *const _,
                Value::from(&natural_width).to_glib_none().0,
            );
        }
    }

    fn get_property_natural_width_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-width-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `natural-width-set` getter")
                .unwrap()
        }
    }

    fn set_property_natural_width_set(&self, natural_width_set: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"natural-width-set\0".as_ptr() as *const _,
                Value::from(&natural_width_set).to_glib_none().0,
            );
        }
    }

    fn get_property_realized(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"realized\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `realized` getter")
                .unwrap()
        }
    }

    fn get_property_rotation_angle_x(&self) -> f64 {
        unsafe {
            let mut value = Value::from_type(<f64 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"rotation-angle-x\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `rotation-angle-x` getter")
                .unwrap()
        }
    }

    fn set_property_rotation_angle_x(&self, rotation_angle_x: f64) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"rotation-angle-x\0".as_ptr() as *const _,
                Value::from(&rotation_angle_x).to_glib_none().0,
            );
        }
    }

    fn get_property_rotation_angle_y(&self) -> f64 {
        unsafe {
            let mut value = Value::from_type(<f64 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"rotation-angle-y\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `rotation-angle-y` getter")
                .unwrap()
        }
    }

    fn set_property_rotation_angle_y(&self, rotation_angle_y: f64) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"rotation-angle-y\0".as_ptr() as *const _,
                Value::from(&rotation_angle_y).to_glib_none().0,
            );
        }
    }

    fn get_property_rotation_angle_z(&self) -> f64 {
        unsafe {
            let mut value = Value::from_type(<f64 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"rotation-angle-z\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `rotation-angle-z` getter")
                .unwrap()
        }
    }

    fn set_property_rotation_angle_z(&self, rotation_angle_z: f64) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"rotation-angle-z\0".as_ptr() as *const _,
                Value::from(&rotation_angle_z).to_glib_none().0,
            );
        }
    }

    fn get_property_scale_x(&self) -> f64 {
        unsafe {
            let mut value = Value::from_type(<f64 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"scale-x\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `scale-x` getter")
                .unwrap()
        }
    }

    fn set_property_scale_x(&self, scale_x: f64) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"scale-x\0".as_ptr() as *const _,
                Value::from(&scale_x).to_glib_none().0,
            );
        }
    }

    fn get_property_scale_y(&self) -> f64 {
        unsafe {
            let mut value = Value::from_type(<f64 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"scale-y\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `scale-y` getter")
                .unwrap()
        }
    }

    fn set_property_scale_y(&self, scale_y: f64) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"scale-y\0".as_ptr() as *const _,
                Value::from(&scale_y).to_glib_none().0,
            );
        }
    }

    fn get_property_show_on_set_parent(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"show-on-set-parent\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `show-on-set-parent` getter")
                .unwrap()
        }
    }

    fn set_property_show_on_set_parent(&self, show_on_set_parent: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"show-on-set-parent\0".as_ptr() as *const _,
                Value::from(&show_on_set_parent).to_glib_none().0,
            );
        }
    }

    fn get_property_transform_set(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"transform-set\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `transform-set` getter")
                .unwrap()
        }
    }

    fn get_property_translation_x(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"translation-x\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `translation-x` getter")
                .unwrap()
        }
    }

    fn set_property_translation_x(&self, translation_x: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"translation-x\0".as_ptr() as *const _,
                Value::from(&translation_x).to_glib_none().0,
            );
        }
    }

    fn get_property_translation_y(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"translation-y\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `translation-y` getter")
                .unwrap()
        }
    }

    fn set_property_translation_y(&self, translation_y: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"translation-y\0".as_ptr() as *const _,
                Value::from(&translation_y).to_glib_none().0,
            );
        }
    }

    fn get_property_translation_z(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"translation-z\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `translation-z` getter")
                .unwrap()
        }
    }

    fn set_property_translation_z(&self, translation_z: f32) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"translation-z\0".as_ptr() as *const _,
                Value::from(&translation_z).to_glib_none().0,
            );
        }
    }

    fn get_property_visible(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"visible\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `visible` getter")
                .unwrap()
        }
    }

    fn set_property_visible(&self, visible: bool) {
        unsafe {
            gobject_sys::g_object_set_property(
                self.to_glib_none().0 as *mut gobject_sys::GObject,
                b"visible\0".as_ptr() as *const _,
                Value::from(&visible).to_glib_none().0,
            );
        }
    }

    fn connect_allocation_changed<F: Fn(&Self, &ActorBox, AllocationFlags) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn allocation_changed_trampoline<
            P,
            F: Fn(&P, &ActorBox, AllocationFlags) + 'static,
        >(
            this: *mut ffi::ClutterActor,
            box_: *mut ffi::ClutterActorBox,
            flags: ffi::ClutterAllocationFlags,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(box_),
                from_glib(flags),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"allocation-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    allocation_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_button_press_event<F: Fn(&Self, &ButtonEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn button_press_event_trampoline<
            P,
            F: Fn(&P, &ButtonEvent) -> bool + 'static,
        >(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterButtonEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"button-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    button_press_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_button_release_event<F: Fn(&Self, &ButtonEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn button_release_event_trampoline<
            P,
            F: Fn(&P, &ButtonEvent) -> bool + 'static,
        >(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterButtonEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"button-release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    button_release_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_captured_event<F: Fn(&Self, &Event) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn captured_event_trampoline<P, F: Fn(&P, &Event) -> bool + 'static>(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"captured-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    captured_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_destroy<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn destroy_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"destroy\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    destroy_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_enter_event<F: Fn(&Self, &CrossingEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn enter_event_trampoline<
            P,
            F: Fn(&P, &CrossingEvent) -> bool + 'static,
        >(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterCrossingEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"enter-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    enter_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_event<F: Fn(&Self, &Event) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn event_trampoline<P, F: Fn(&P, &Event) -> bool + 'static>(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_hide<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hide_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"hide\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    hide_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_key_focus_in<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn key_focus_in_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"key-focus-in\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    key_focus_in_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_key_focus_out<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn key_focus_out_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"key-focus-out\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    key_focus_out_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_key_press_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn key_press_event_trampoline<P, F: Fn(&P, &KeyEvent) -> bool + 'static>(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterKeyEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"key-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    key_press_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_key_release_event<F: Fn(&Self, &KeyEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn key_release_event_trampoline<
            P,
            F: Fn(&P, &KeyEvent) -> bool + 'static,
        >(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterKeyEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"key-release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    key_release_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_leave_event<F: Fn(&Self, &CrossingEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn leave_event_trampoline<
            P,
            F: Fn(&P, &CrossingEvent) -> bool + 'static,
        >(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterCrossingEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"leave-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    leave_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_motion_event<F: Fn(&Self, &MotionEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn motion_event_trampoline<P, F: Fn(&P, &MotionEvent) -> bool + 'static>(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterMotionEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"motion-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    motion_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_parent_set<F: Fn(&Self, Option<&Actor>) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn parent_set_trampoline<P, F: Fn(&P, Option<&Actor>) + 'static>(
            this: *mut ffi::ClutterActor,
            old_parent: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                Option::<Actor>::from_glib_borrow(old_parent)
                    .as_ref()
                    .as_ref(),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"parent-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    parent_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_queue_redraw<F: Fn(&Self, &Actor) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn queue_redraw_trampoline<P, F: Fn(&P, &Actor) + 'static>(
            this: *mut ffi::ClutterActor,
            origin: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(origin),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"queue-redraw\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    queue_redraw_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_queue_relayout<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn queue_relayout_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"queue-relayout\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    queue_relayout_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_scroll_event<F: Fn(&Self, &ScrollEvent) -> bool + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn scroll_event_trampoline<P, F: Fn(&P, &ScrollEvent) -> bool + 'static>(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterScrollEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"scroll-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    scroll_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_show<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"show\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    show_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_touch_event<F: Fn(&Self, &Event) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn touch_event_trampoline<P, F: Fn(&P, &Event) -> bool + 'static>(
            this: *mut ffi::ClutterActor,
            event: *mut ffi::ClutterEvent,
            f: glib_sys::gpointer,
        ) -> glib_sys::gboolean
        where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_none(event),
            )
            .to_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"touch-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    touch_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_transition_stopped<F: Fn(&Self, &str, bool) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn transition_stopped_trampoline<P, F: Fn(&P, &str, bool) + 'static>(
            this: *mut ffi::ClutterActor,
            name: *mut libc::c_char,
            is_finished: glib_sys::gboolean,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(
                &Actor::from_glib_borrow(this).unsafe_cast_ref(),
                &GString::from_glib_borrow(name),
                from_glib(is_finished),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"transition-stopped\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    transition_stopped_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_transitions_completed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn transitions_completed_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"transitions-completed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    transitions_completed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_actions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_actions_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::actions\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_actions_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_allocation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allocation_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::allocation\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_allocation_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_background_color_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_background_color_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::background-color\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_background_color_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_background_color_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_background_color_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::background-color-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_background_color_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_child_transform_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_child_transform_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::child-transform\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_child_transform_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_child_transform_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_child_transform_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::child-transform-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_child_transform_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_clip_rect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_clip_rect_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::clip-rect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_clip_rect_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_clip_to_allocation_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_clip_to_allocation_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::clip-to-allocation\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_clip_to_allocation_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_constraints_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_constraints_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::constraints\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_constraints_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_content_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::content\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_content_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_content_box_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_box_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::content-box\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_content_box_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_content_gravity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_gravity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::content-gravity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_content_gravity_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_content_repeat_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_repeat_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::content-repeat\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_content_repeat_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_effect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_effect_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::effect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_effect_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_first_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_first_child_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::first-child\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_first_child_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_fixed_position_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_fixed_position_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::fixed-position-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_fixed_position_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_fixed_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_fixed_x_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::fixed-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_fixed_x_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_fixed_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_fixed_y_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::fixed-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_fixed_y_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_has_clip_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_clip_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::has-clip\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_has_clip_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_has_pointer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_pointer_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::has-pointer\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_has_pointer_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_height_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_height_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_last_child_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_last_child_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::last-child\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_last_child_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_layout_manager_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_layout_manager_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::layout-manager\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_layout_manager_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_magnification_filter_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_magnification_filter_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::magnification-filter\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_magnification_filter_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_mapped_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mapped_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::mapped\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_mapped_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_margin_bottom_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_bottom_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::margin-bottom\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_margin_bottom_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_margin_left_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_left_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::margin-left\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_margin_left_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_margin_right_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_right_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::margin-right\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_margin_right_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_margin_top_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_margin_top_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::margin-top\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_margin_top_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_min_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_height_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::min-height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_min_height_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_min_height_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_height_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::min-height-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_min_height_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_min_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_width_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::min-width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_min_width_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_min_width_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_min_width_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::min-width-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_min_width_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_minification_filter_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_minification_filter_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::minification-filter\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_minification_filter_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_name_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_natural_height_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_height_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::natural-height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_natural_height_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_natural_height_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_height_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::natural-height-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_natural_height_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_natural_width_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_width_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::natural-width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_natural_width_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_natural_width_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_natural_width_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::natural-width-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_natural_width_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_offscreen_redirect_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_offscreen_redirect_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::offscreen-redirect\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_offscreen_redirect_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_opacity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_opacity_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::opacity\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_opacity_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_pivot_point_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pivot_point_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pivot-point\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_pivot_point_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_pivot_point_z_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_pivot_point_z_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pivot-point-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_pivot_point_z_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_position_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_position_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_reactive_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_reactive_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::reactive\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_reactive_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_realized_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_realized_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::realized\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_realized_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_request_mode_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_request_mode_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::request-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_request_mode_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_rotation_angle_x_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_rotation_angle_x_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::rotation-angle-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_rotation_angle_x_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_rotation_angle_y_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_rotation_angle_y_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::rotation-angle-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_rotation_angle_y_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_rotation_angle_z_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_rotation_angle_z_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::rotation-angle-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_rotation_angle_z_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_scale_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_x_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::scale-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_scale_x_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_scale_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_y_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::scale-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_scale_y_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_scale_z_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_z_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::scale-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_scale_z_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_show_on_set_parent_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_on_set_parent_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::show-on-set-parent\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_show_on_set_parent_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_size_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::size\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_size_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_text_direction_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_text_direction_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::text-direction\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_text_direction_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_transform_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transform_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::transform\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_transform_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_transform_set_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_transform_set_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::transform-set\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_transform_set_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_translation_x_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_translation_x_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::translation-x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_translation_x_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_translation_y_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_translation_y_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::translation-y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_translation_y_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_translation_z_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_translation_z_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::translation-z\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_translation_z_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_visible_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::visible\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_visible_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_width_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_width_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::x\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_x_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_x_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_align_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::x-align\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_x_align_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_x_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_expand_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::x-expand\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_x_expand_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::y\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_y_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_y_align_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_align_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::y-align\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_y_align_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_y_expand_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_y_expand_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::y-expand\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_y_expand_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_z_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_z_position_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterActor,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Actor>,
        {
            let f: &F = &*(f as *const F);
            f(&Actor::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::z-position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_z_position_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Actor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Actor")
    }
}
