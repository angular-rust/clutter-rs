// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use super::Knot;
use super::PathNode;

glib_wrapper! {
    pub struct Path(Object<ffi::ClutterPath, ffi::ClutterPathClass, PathClass>);

    match fn {
        get_type => || ffi::clutter_path_get_type(),
    }
}

impl Path {
    pub fn new() -> Path {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::clutter_path_new()) }
    }

    pub fn with_description(desc: &str) -> Path {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::clutter_path_new_with_description(
                desc.to_glib_none().0,
            ))
        }
    }
}

impl Default for Path {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_PATH: Option<&Path> = None;

pub trait PathExt: 'static {
    fn add_close(&self);

    fn add_curve_to(&self, x_1: i32, y_1: i32, x_2: i32, y_2: i32, x_3: i32, y_3: i32);

    fn add_line_to(&self, x: i32, y: i32);

    fn add_move_to(&self, x: i32, y: i32);

    fn add_node(&self, node: &PathNode);

    fn add_rel_curve_to(&self, x_1: i32, y_1: i32, x_2: i32, y_2: i32, x_3: i32, y_3: i32);

    fn add_rel_line_to(&self, x: i32, y: i32);

    fn add_rel_move_to(&self, x: i32, y: i32);

    fn add_string(&self, str: &str) -> bool;

    fn clear(&self);

    fn foreach<P: FnMut(&PathNode)>(&self, callback: P);

    fn get_description(&self) -> Option<GString>;

    fn get_length(&self) -> u32;

    fn get_n_nodes(&self) -> u32;

    fn get_node(&self, index_: u32) -> PathNode;

    fn get_nodes(&self) -> Vec<PathNode>;

    fn get_position(&self, progress: f64) -> (u32, Knot);

    fn insert_node(&self, index_: i32, node: &PathNode);

    fn remove_node(&self, index_: u32);

    fn replace_node(&self, index_: u32, node: &PathNode);

    fn set_description(&self, str: &str) -> bool;

    fn connect_property_description_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Path>> PathExt for O {
    fn add_close(&self) {
        unsafe {
            ffi::clutter_path_add_close(self.as_ref().to_glib_none().0);
        }
    }

    fn add_curve_to(&self, x_1: i32, y_1: i32, x_2: i32, y_2: i32, x_3: i32, y_3: i32) {
        unsafe {
            ffi::clutter_path_add_curve_to(
                self.as_ref().to_glib_none().0,
                x_1,
                y_1,
                x_2,
                y_2,
                x_3,
                y_3,
            );
        }
    }

    fn add_line_to(&self, x: i32, y: i32) {
        unsafe {
            ffi::clutter_path_add_line_to(self.as_ref().to_glib_none().0, x, y);
        }
    }

    fn add_move_to(&self, x: i32, y: i32) {
        unsafe {
            ffi::clutter_path_add_move_to(self.as_ref().to_glib_none().0, x, y);
        }
    }

    fn add_node(&self, node: &PathNode) {
        unsafe {
            ffi::clutter_path_add_node(
                self.as_ref().to_glib_none().0,
                node.to_glib_none().0,
            );
        }
    }

    fn add_rel_curve_to(&self, x_1: i32, y_1: i32, x_2: i32, y_2: i32, x_3: i32, y_3: i32) {
        unsafe {
            ffi::clutter_path_add_rel_curve_to(
                self.as_ref().to_glib_none().0,
                x_1,
                y_1,
                x_2,
                y_2,
                x_3,
                y_3,
            );
        }
    }

    fn add_rel_line_to(&self, x: i32, y: i32) {
        unsafe {
            ffi::clutter_path_add_rel_line_to(self.as_ref().to_glib_none().0, x, y);
        }
    }

    fn add_rel_move_to(&self, x: i32, y: i32) {
        unsafe {
            ffi::clutter_path_add_rel_move_to(self.as_ref().to_glib_none().0, x, y);
        }
    }

    fn add_string(&self, str: &str) -> bool {
        unsafe {
            from_glib(ffi::clutter_path_add_string(
                self.as_ref().to_glib_none().0,
                str.to_glib_none().0,
            ))
        }
    }

    fn clear(&self) {
        unsafe {
            ffi::clutter_path_clear(self.as_ref().to_glib_none().0);
        }
    }

    fn foreach<P: FnMut(&PathNode)>(&self, callback: P) {
        let callback_data: P = callback;
        unsafe extern "C" fn callback_func<P: FnMut(&PathNode)>(
            node: *const ffi::ClutterPathNode,
            data: glib_sys::gpointer,
        ) {
            let node = from_glib_borrow(node);
            let callback: *mut P = data as *const _ as usize as *mut P;
            (*callback)(&node);
        }
        let callback = Some(callback_func::<P> as _);
        let super_callback0: &P = &callback_data;
        unsafe {
            ffi::clutter_path_foreach(
                self.as_ref().to_glib_none().0,
                callback,
                super_callback0 as *const _ as usize as *mut _,
            );
        }
    }

    fn get_description(&self) -> Option<GString> {
        unsafe {
            from_glib_full(ffi::clutter_path_get_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_length(&self) -> u32 {
        unsafe { ffi::clutter_path_get_length(self.as_ref().to_glib_none().0) }
    }

    fn get_n_nodes(&self) -> u32 {
        unsafe { ffi::clutter_path_get_n_nodes(self.as_ref().to_glib_none().0) }
    }

    fn get_node(&self, index_: u32) -> PathNode {
        unsafe {
            let mut node = PathNode::uninitialized();
            ffi::clutter_path_get_node(
                self.as_ref().to_glib_none().0,
                index_,
                node.to_glib_none_mut().0,
            );
            node
        }
    }

    fn get_nodes(&self) -> Vec<PathNode> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::clutter_path_get_nodes(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn get_position(&self, progress: f64) -> (u32, Knot) {
        unsafe {
            let mut position = Knot::uninitialized();
            let ret = ffi::clutter_path_get_position(
                self.as_ref().to_glib_none().0,
                progress,
                position.to_glib_none_mut().0,
            );
            (ret, position)
        }
    }

    fn insert_node(&self, index_: i32, node: &PathNode) {
        unsafe {
            ffi::clutter_path_insert_node(
                self.as_ref().to_glib_none().0,
                index_,
                node.to_glib_none().0,
            );
        }
    }

    fn remove_node(&self, index_: u32) {
        unsafe {
            ffi::clutter_path_remove_node(self.as_ref().to_glib_none().0, index_);
        }
    }

    fn replace_node(&self, index_: u32, node: &PathNode) {
        unsafe {
            ffi::clutter_path_replace_node(
                self.as_ref().to_glib_none().0,
                index_,
                node.to_glib_none().0,
            );
        }
    }

    fn set_description(&self, str: &str) -> bool {
        unsafe {
            from_glib(ffi::clutter_path_set_description(
                self.as_ref().to_glib_none().0,
                str.to_glib_none().0,
            ))
        }
    }

    fn connect_property_description_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_description_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterPath,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Path>,
        {
            let f: &F = &*(f as *const F);
            f(&Path::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::description\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_description_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_property_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_length_trampoline<P, F: Fn(&P) + 'static>(
            this: *mut ffi::ClutterPath,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) where
            P: IsA<Path>,
        {
            let f: &F = &*(f as *const F);
            f(&Path::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::length\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_length_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Path {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Path")
    }
}
