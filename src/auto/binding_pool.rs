// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::object::ObjectType as ObjectType_;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use gobject_sys;
use std::fmt;
use super::ModifierType;

glib_wrapper! {
    pub struct BindingPool(Object<ffi::ClutterBindingPool, ffi::ClutterBindingPoolClass, BindingPoolClass>);

    match fn {
        get_type => || ffi::clutter_binding_pool_get_type(),
    }
}

impl BindingPool {
    pub fn new(name: &str) -> BindingPool {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::clutter_binding_pool_new(name.to_glib_none().0)) }
    }

    //pub fn activate(&self, key_val: u32, modifiers: ModifierType, gobject: /*Ignored*/&glib::Object) -> bool {
    //    unsafe { TODO: call clutter_sys:clutter_binding_pool_activate() }
    //}

    pub fn block_action(&self, action_name: &str) {
        unsafe {
            ffi::clutter_binding_pool_block_action(
                self.to_glib_none().0,
                action_name.to_glib_none().0,
            );
        }
    }

    pub fn find_action(&self, key_val: u32, modifiers: ModifierType) -> Option<GString> {
        unsafe {
            from_glib_none(ffi::clutter_binding_pool_find_action(
                self.to_glib_none().0,
                key_val,
                modifiers.to_glib(),
            ))
        }
    }

    //pub fn install_action(&self, action_name: &str, key_val: u32, modifiers: ModifierType, callback: /*Unimplemented*/Fn(/*Ignored*/glib::Object, &str, u32, &ModifierType) -> bool, data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call clutter_sys:clutter_binding_pool_install_action() }
    //}

    //pub fn install_closure(&self, action_name: &str, key_val: u32, modifiers: ModifierType, closure: /*Ignored*/&glib::Closure) {
    //    unsafe { TODO: call clutter_sys:clutter_binding_pool_install_closure() }
    //}

    //pub fn override_action(&self, key_val: u32, modifiers: ModifierType, callback: /*Unimplemented*/Fn(/*Ignored*/glib::Object, &str, u32, &ModifierType) -> bool, data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call clutter_sys:clutter_binding_pool_override_action() }
    //}

    //pub fn override_closure(&self, key_val: u32, modifiers: ModifierType, closure: /*Ignored*/&glib::Closure) {
    //    unsafe { TODO: call clutter_sys:clutter_binding_pool_override_closure() }
    //}

    pub fn remove_action(&self, key_val: u32, modifiers: ModifierType) {
        unsafe {
            ffi::clutter_binding_pool_remove_action(
                self.to_glib_none().0,
                key_val,
                modifiers.to_glib(),
            );
        }
    }

    pub fn unblock_action(&self, action_name: &str) {
        unsafe {
            ffi::clutter_binding_pool_unblock_action(
                self.to_glib_none().0,
                action_name.to_glib_none().0,
            );
        }
    }

    pub fn get_property_name(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(
                self.as_ptr() as *mut gobject_sys::GObject,
                b"name\0".as_ptr() as *const _,
                value.to_glib_none_mut().0,
            );
            value
                .get()
                .expect("Return Value for property `name` getter")
        }
    }

    pub fn find(name: &str) -> Option<BindingPool> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::clutter_binding_pool_find(
                name.to_glib_none().0,
            ))
        }
    }

    //pub fn get_for_class(klass: /*Unimplemented*/Option<Fundamental: Pointer>) -> Option<BindingPool> {
    //    unsafe { TODO: call clutter_sys:clutter_binding_pool_get_for_class() }
    //}
}

impl fmt::Display for BindingPool {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "BindingPool")
    }
}
